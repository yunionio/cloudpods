// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package s3 provides a client for Amazon Simple Storage Service.
package s3

import (
	"context"
	"github.com/ks3sdklib/aws-sdk-go/aws"
	"github.com/ks3sdklib/aws-sdk-go/aws/awserr"
	"github.com/ks3sdklib/aws-sdk-go/internal/apierr"
	"github.com/ks3sdklib/aws-sdk-go/internal/crc"
	"hash"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// AbortMultipartUploadRequest generates a request for the AbortMultipartUpload operation.
func (c *S3) AbortMultipartUploadRequest(input *AbortMultipartUploadInput) (req *aws.Request, output *AbortMultipartUploadOutput) {
	op := &aws.Operation{
		Name:       "AbortMultipartUpload",
		HTTPMethod: "DELETE",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &AbortMultipartUploadInput{}
	}

	req = c.newRequest(op, input, output)
	output = &AbortMultipartUploadOutput{}
	req.Data = output
	return
}

// AbortMultipartUpload Aborts a multipart upload.
//
// To verify that all parts have been removed, so you don't get charged for
// the part storage, you should call the List Parts operation and ensure the
// parts list is empty.
func (c *S3) AbortMultipartUpload(input *AbortMultipartUploadInput) (*AbortMultipartUploadOutput, error) {
	req, out := c.AbortMultipartUploadRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) AbortMultipartUploadWithContext(ctx aws.Context, input *AbortMultipartUploadInput) (*AbortMultipartUploadOutput, error) {
	req, out := c.AbortMultipartUploadRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// CompleteMultipartUploadRequest generates a request for the CompleteMultipartUpload operation.
func (c *S3) CompleteMultipartUploadRequest(input *CompleteMultipartUploadInput) (req *aws.Request, output *CompleteMultipartUploadOutput) {
	op := &aws.Operation{
		Name:       "CompleteMultipartUpload",
		HTTPMethod: "POST",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &CompleteMultipartUploadInput{}
	}

	req = c.newRequest(op, input, output)
	output = &CompleteMultipartUploadOutput{}
	req.Data = output
	return
}

// CompleteMultipartUpload Completes a multipart upload by assembling previously uploaded parts.
func (c *S3) CompleteMultipartUpload(input *CompleteMultipartUploadInput) (*CompleteMultipartUploadOutput, error) {
	req, out := c.CompleteMultipartUploadRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) CompleteMultipartUploadWithContext(ctx aws.Context, input *CompleteMultipartUploadInput) (*CompleteMultipartUploadOutput, error) {
	req, out := c.CompleteMultipartUploadRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// CopyObjectRequest generates a request for the CopyObject operation.
func (c *S3) CopyObjectRequest(input *CopyObjectInput) (req *aws.Request, output *CopyObjectOutput) {
	op := &aws.Operation{
		Name:       "CopyObject",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &CopyObjectInput{}
	}

	// URL encode the copy source
	if input.CopySource == nil {
		input.CopySource = aws.String(BuildCopySource(input.SourceBucket, input.SourceKey))
	}
	req = c.newRequest(op, input, output)
	output = &CopyObjectOutput{}
	req.Data = output
	return
}

// CopyObject Creates a copy of an object that is already stored in KS3.
func (c *S3) CopyObject(input *CopyObjectInput) (*CopyObjectOutput, error) {
	req, out := c.CopyObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) CopyObjectWithContext(ctx aws.Context, input *CopyObjectInput) (*CopyObjectOutput, error) {
	req, out := c.CopyObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// CreateBucketRequest generates a request for the CreateBucket operation.
func (c *S3) CreateBucketRequest(input *CreateBucketInput) (req *aws.Request, output *CreateBucketOutput) {
	var op *aws.Operation
	if input.ProjectId == nil {
		op = &aws.Operation{
			Name:       "CreateBucket",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}",
		}
	} else {
		op = &aws.Operation{
			Name:       "CreateBucket",
			HTTPMethod: "PUT",
			HTTPPath:   "/{Bucket}?projectId=" + *input.ProjectId,
		}
	}

	if input == nil {
		input = &CreateBucketInput{}
	}

	req = c.newRequest(op, input, output)
	output = &CreateBucketOutput{}
	req.Data = output
	return
}

// CreateBucket Creates a new bucket.
func (c *S3) CreateBucket(input *CreateBucketInput) (*CreateBucketOutput, error) {
	req, out := c.CreateBucketRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) CreateBucketWithContext(ctx aws.Context, input *CreateBucketInput) (*CreateBucketOutput, error) {
	req, out := c.CreateBucketRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// CreateMultipartUploadRequest generates a request for the CreateMultipartUpload operation.
func (c *S3) CreateMultipartUploadRequest(input *CreateMultipartUploadInput) (req *aws.Request, output *CreateMultipartUploadOutput) {
	op := &aws.Operation{
		Name:       "CreateMultipartUpload",
		HTTPMethod: "POST",
		HTTPPath:   "/{Bucket}/{Key+}?uploads",
	}

	if input == nil {
		input = &CreateMultipartUploadInput{}
	}

	req = c.newRequest(op, input, output)
	output = &CreateMultipartUploadOutput{}
	req.Data = output
	return
}

// CreateMultipartUpload Initiates a multipart upload and returns an upload ID.
//
// Note: After you initiate multipart upload and upload one or more parts,
// you must either complete or abort multipart upload in order to stop getting
// charged for storage of the uploaded parts. Only after you either complete
// or abort multipart upload, Amazon S3 frees up the parts storage and stops
// charging you for the parts storage.
func (c *S3) CreateMultipartUpload(input *CreateMultipartUploadInput) (*CreateMultipartUploadOutput, error) {
	req, out := c.CreateMultipartUploadRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) CreateMultipartUploadWithContext(ctx aws.Context, input *CreateMultipartUploadInput) (*CreateMultipartUploadOutput, error) {
	req, out := c.CreateMultipartUploadRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// DeleteBucketRequest generates a request for the DeleteBucket operation.
func (c *S3) DeleteBucketRequest(input *DeleteBucketInput) (req *aws.Request, output *DeleteBucketOutput) {
	op := &aws.Operation{
		Name:       "DeleteBucket",
		HTTPMethod: "DELETE",
		HTTPPath:   "/{Bucket}",
	}

	if input == nil {
		input = &DeleteBucketInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteBucketOutput{}
	req.Data = output
	return
}

// DeleteBucket Deletes the bucket. All objects (including all object versions and Delete
// Markers) in the bucket must be deleted before the bucket itself can be deleted.
func (c *S3) DeleteBucket(input *DeleteBucketInput) (*DeleteBucketOutput, error) {
	req, out := c.DeleteBucketRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) DeleteBucketWithContext(ctx aws.Context, input *DeleteBucketInput) (*DeleteBucketOutput, error) {
	req, out := c.DeleteBucketRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// DeleteBucketPolicyRequest generates a request for the DeleteBucketPolicy operation.
func (c *S3) DeleteBucketPolicyRequest(input *DeleteBucketPolicyInput) (req *aws.Request, output *DeleteBucketPolicyOutput) {
	op := &aws.Operation{
		Name:       "DeleteBucketPolicy",
		HTTPMethod: "DELETE",
		HTTPPath:   "/{Bucket}?policy",
	}

	if input == nil {
		input = &DeleteBucketPolicyInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteBucketPolicyOutput{}
	req.Data = output
	return
}

// DeleteBucketPolicy Deletes the policy from the bucket.
func (c *S3) DeleteBucketPolicy(input *DeleteBucketPolicyInput) (*DeleteBucketPolicyOutput, error) {
	req, out := c.DeleteBucketPolicyRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) DeleteBucketPolicyWithContext(ctx aws.Context, input *DeleteBucketPolicyInput) (*DeleteBucketPolicyOutput, error) {
	req, out := c.DeleteBucketPolicyRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// DeleteBucketWebsiteRequest generates a request for the DeleteBucketWebsite operation.
func (c *S3) DeleteBucketWebsiteRequest(input *DeleteBucketWebsiteInput) (req *aws.Request, output *DeleteBucketWebsiteOutput) {
	op := &aws.Operation{
		Name:       "DeleteBucketWebsite",
		HTTPMethod: "DELETE",
		HTTPPath:   "/{Bucket}?website",
	}

	if input == nil {
		input = &DeleteBucketWebsiteInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteBucketWebsiteOutput{}
	req.Data = output
	return
}

// DeleteBucketWebsite This operation removes the website configuration from the bucket.
func (c *S3) DeleteBucketWebsite(input *DeleteBucketWebsiteInput) (*DeleteBucketWebsiteOutput, error) {
	req, out := c.DeleteBucketWebsiteRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) DeleteBucketWebsiteWithContext(ctx aws.Context, input *DeleteBucketWebsiteInput) (*DeleteBucketWebsiteOutput, error) {
	req, out := c.DeleteBucketWebsiteRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// DeleteObjectRequest generates a request for the DeleteObject operation.
func (c *S3) DeleteObjectRequest(input *DeleteObjectInput) (req *aws.Request, output *DeleteObjectOutput) {
	op := &aws.Operation{
		Name:       "DeleteObject",
		HTTPMethod: "DELETE",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &DeleteObjectInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteObjectOutput{}
	req.Data = output
	return
}

// DeleteObject Removes the null version (if there is one) of an object and inserts a delete
// marker, which becomes the latest version of the object. If there isn't a
// null version, Amazon S3 does not remove any objects.
func (c *S3) DeleteObject(input *DeleteObjectInput) (*DeleteObjectOutput, error) {
	req, out := c.DeleteObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) DeleteObjectWithContext(ctx aws.Context, input *DeleteObjectInput) (*DeleteObjectOutput, error) {
	req, out := c.DeleteObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// DeleteObjectsRequest generates a request for the DeleteObjects operation.
func (c *S3) DeleteObjectsRequest(input *DeleteObjectsInput) (req *aws.Request, output *DeleteObjectsOutput) {
	op := &aws.Operation{
		Name:       "DeleteObjects",
		HTTPMethod: "POST",
		HTTPPath:   "/{Bucket}?delete",
	}

	if input == nil {
		input = &DeleteObjectsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteObjectsOutput{}
	req.Data = output
	return
}

func (c *S3) DeleteObjects(input *DeleteObjectsInput) (*DeleteObjectsOutput, error) {
	return c.DeleteObjectsWithContext(context.Background(), input)
}

func (c *S3) DeleteObjectsWithContext(ctx aws.Context, input *DeleteObjectsInput) (*DeleteObjectsOutput, error) {
	var errors []*Error
	var okList []*DeletedObject
	if input == nil {
		input = &DeleteObjectsInput{}
	}
	for _, t := range input.Delete.Objects {
		_, err := c.DeleteObjectWithContext(ctx, &DeleteObjectInput{Bucket: input.Bucket, Key: t.Key})
		if input.IsReTurnResults != nil && *input.IsReTurnResults == true {
			if err != nil {
				aerr, _ := err.(awserr.Error)
				errors = append(errors, &Error{Key: t.Key, Code: aws.String(aerr.Code()), Message: aws.String(aerr.Message())})
			} else {
				okList = append(okList, &DeletedObject{Key: t.Key})
			}
		}
	}
	output := &DeleteObjectsOutput{
		Deleted: okList,
		Errors:  errors,
	}
	return output, nil
}

// DeleteBucketPrefix deletes all objects with the specified prefix in the bucket.
func (c *S3) DeleteBucketPrefix(input *DeleteBucketPrefixInput) (*DeleteObjectsOutput, error) {
	return c.DeleteBucketPrefixWithContext(context.Background(), input)
}

func (c *S3) DeleteBucketPrefixWithContext(ctx aws.Context, input *DeleteBucketPrefixInput) (*DeleteObjectsOutput, error) {
	var errors []*Error
	var okList []*DeletedObject

	var output = &DeleteObjectsOutput{
		Deleted: okList,
		Errors:  errors,
	}
	if input == nil {
		input = &DeleteBucketPrefixInput{}
	}
	marker := aws.String("")
	maxKeys := aws.Long(100)
	if input.MaxKeys != nil {
		maxKeys = input.MaxKeys
	}
	for {
		resp, err := c.ListObjectsWithContext(ctx, &ListObjectsInput{
			Bucket:  input.Bucket,
			Prefix:  input.Prefix,
			Marker:  marker,
			MaxKeys: maxKeys,
		})
		if err == nil {
			for _, t := range resp.Contents {
				_, err := c.DeleteObjectWithContext(ctx, &DeleteObjectInput{Bucket: input.Bucket, Key: t.Key})
				if input.IsReTurnResults != nil && *input.IsReTurnResults == true {
					if err != nil {
						aerr, _ := err.(awserr.Error)
						errors = append(errors, &Error{Key: t.Key, Code: aws.String(aerr.Code()), Message: aws.String(aerr.Message())})
						output.Errors = errors
					} else {
						okList = append(okList, &DeletedObject{Key: t.Key})
						output.Deleted = okList
					}
				}
			}
			if *resp.IsTruncated == false {
				break
			}
			marker = resp.Contents[*maxKeys-1].Key
		} else {
			return output, err
		}
	}
	return output, nil
}

// TryDeleteBucketPrefix deletes all objects with the specified prefix in the bucket, and retries at most 3 times.
func (c *S3) TryDeleteBucketPrefix(input *DeleteBucketPrefixInput) (*DeleteObjectsOutput, error) {
	return c.TryDeleteBucketPrefixWithContext(context.Background(), input)
}

func (c *S3) TryDeleteBucketPrefixWithContext(ctx aws.Context, input *DeleteBucketPrefixInput) (*DeleteObjectsOutput, error) {
	params := input
	var output *DeleteObjectsOutput
	err := Do(func(attempt int) (bool, error) {
		var err error
		output, err = c.DeleteBucketPrefixWithContext(ctx, params)
		return attempt < 3, err // 重试3次
	})
	return output, err
}

// GetBucketACLRequest generates a request for the GetBucketACL operation.
func (c *S3) GetBucketACLRequest(input *GetBucketACLInput) (req *aws.Request, output *GetBucketACLOutput) {
	op := &aws.Operation{
		Name:       "GetBucketAcl",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?acl",
	}

	if input == nil {
		input = &GetBucketACLInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetBucketACLOutput{}
	req.Data = output
	return
}

// GetBucketACL Gets the access control policy for the bucket.
func (c *S3) GetBucketACL(input *GetBucketACLInput) (*GetBucketACLOutput, error) {
	req, out := c.GetBucketACLRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketACLWithContext(ctx aws.Context, input *GetBucketACLInput) (*GetBucketACLOutput, error) {
	req, out := c.GetBucketACLRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketLocationRequest generates a request for the GetBucketLocation operation.
func (c *S3) GetBucketLocationRequest(input *GetBucketLocationInput) (req *aws.Request, output *GetBucketLocationOutput) {
	op := &aws.Operation{
		Name:       "GetBucketLocation",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?location",
	}

	if input == nil {
		input = &GetBucketLocationInput{}
	}

	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.PushFront(buildGetBucketLocation)
	output = &GetBucketLocationOutput{}
	req.Data = output
	return
}

// GetBucketLocation Returns the region the bucket resides in.
func (c *S3) GetBucketLocation(input *GetBucketLocationInput) (*GetBucketLocationOutput, error) {
	req, out := c.GetBucketLocationRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketLocationWithContext(ctx aws.Context, input *GetBucketLocationInput) (*GetBucketLocationOutput, error) {
	req, out := c.GetBucketLocationRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketLoggingRequest generates a request for the GetBucketLogging operation.
func (c *S3) GetBucketLoggingRequest(input *GetBucketLoggingInput) (req *aws.Request, output *GetBucketLoggingOutput) {
	op := &aws.Operation{
		Name:       "GetBucketLogging",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?logging",
	}

	if input == nil {
		input = &GetBucketLoggingInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetBucketLoggingOutput{}
	req.Data = output
	return
}

// GetBucketLogging Returns the logging status of a bucket and the permissions users have to
// view and modify that status. To use GET, you must be the bucket owner.
func (c *S3) GetBucketLogging(input *GetBucketLoggingInput) (*GetBucketLoggingOutput, error) {
	req, out := c.GetBucketLoggingRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketLoggingWithContext(ctx aws.Context, input *GetBucketLoggingInput) (*GetBucketLoggingOutput, error) {
	req, out := c.GetBucketLoggingRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketNotificationRequest generates a request for the GetBucketNotification operation.
func (c *S3) GetBucketNotificationRequest(input *GetBucketNotificationConfigurationRequest) (req *aws.Request, output *NotificationConfigurationDeprecated) {
	op := &aws.Operation{
		Name:       "GetBucketNotification",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?notification",
	}

	if input == nil {
		input = &GetBucketNotificationConfigurationRequest{}
	}

	req = c.newRequest(op, input, output)
	output = &NotificationConfigurationDeprecated{}
	req.Data = output
	return
}

// GetBucketNotification Deprecated, see the GetBucketNotificationConfiguration operation.
func (c *S3) GetBucketNotification(input *GetBucketNotificationConfigurationRequest) (*NotificationConfigurationDeprecated, error) {
	req, out := c.GetBucketNotificationRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketNotificationWithContext(ctx aws.Context, input *GetBucketNotificationConfigurationRequest) (*NotificationConfigurationDeprecated, error) {
	req, out := c.GetBucketNotificationRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketNotificationConfigurationRequest generates a request for the GetBucketNotificationConfiguration operation.
func (c *S3) GetBucketNotificationConfigurationRequest(input *GetBucketNotificationConfigurationRequest) (req *aws.Request, output *NotificationConfiguration) {
	op := &aws.Operation{
		Name:       "GetBucketNotificationConfiguration",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?notification",
	}

	if input == nil {
		input = &GetBucketNotificationConfigurationRequest{}
	}

	req = c.newRequest(op, input, output)
	output = &NotificationConfiguration{}
	req.Data = output
	return
}

// GetBucketNotificationConfiguration Returns the notification configuration of a bucket.
func (c *S3) GetBucketNotificationConfiguration(input *GetBucketNotificationConfigurationRequest) (*NotificationConfiguration, error) {
	req, out := c.GetBucketNotificationConfigurationRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketNotificationConfigurationWithContext(ctx aws.Context, input *GetBucketNotificationConfigurationRequest) (*NotificationConfiguration, error) {
	req, out := c.GetBucketNotificationConfigurationRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketPolicyRequest generates a request for the GetBucketPolicy operation.
func (c *S3) GetBucketPolicyRequest(input *GetBucketPolicyInput) (req *aws.Request, output *GetBucketPolicyOutput) {
	op := &aws.Operation{
		Name:       "GetBucketPolicy",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?policy",
	}

	if input == nil {
		input = &GetBucketPolicyInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetBucketPolicyOutput{}
	req.Data = output
	return
}

// GetBucketPolicy Returns the policy of a specified bucket.
func (c *S3) GetBucketPolicy(input *GetBucketPolicyInput) (*GetBucketPolicyOutput, error) {
	req, out := c.GetBucketPolicyRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketPolicyWithContext(ctx aws.Context, input *GetBucketPolicyInput) (*GetBucketPolicyOutput, error) {
	req, out := c.GetBucketPolicyRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketRequestPaymentRequest generates a request for the GetBucketRequestPayment operation.
func (c *S3) GetBucketRequestPaymentRequest(input *GetBucketRequestPaymentInput) (req *aws.Request, output *GetBucketRequestPaymentOutput) {
	op := &aws.Operation{
		Name:       "GetBucketRequestPayment",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?requestPayment",
	}

	if input == nil {
		input = &GetBucketRequestPaymentInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetBucketRequestPaymentOutput{}
	req.Data = output
	return
}

// GetBucketRequestPayment Returns the request payment configuration of a bucket.
func (c *S3) GetBucketRequestPayment(input *GetBucketRequestPaymentInput) (*GetBucketRequestPaymentOutput, error) {
	req, out := c.GetBucketRequestPaymentRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketRequestPaymentWithContext(ctx aws.Context, input *GetBucketRequestPaymentInput) (*GetBucketRequestPaymentOutput, error) {
	req, out := c.GetBucketRequestPaymentRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketVersioningRequest generates a request for the GetBucketVersioning operation.
func (c *S3) GetBucketVersioningRequest(input *GetBucketVersioningInput) (req *aws.Request, output *GetBucketVersioningOutput) {
	op := &aws.Operation{
		Name:       "GetBucketVersioning",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?versioning",
	}

	if input == nil {
		input = &GetBucketVersioningInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetBucketVersioningOutput{}
	req.Data = output
	return
}

// GetBucketVersioning Returns the versioning state of a bucket.
func (c *S3) GetBucketVersioning(input *GetBucketVersioningInput) (*GetBucketVersioningOutput, error) {
	req, out := c.GetBucketVersioningRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketVersioningWithContext(ctx aws.Context, input *GetBucketVersioningInput) (*GetBucketVersioningOutput, error) {
	req, out := c.GetBucketVersioningRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetBucketWebsiteRequest generates a request for the GetBucketWebsite operation.
func (c *S3) GetBucketWebsiteRequest(input *GetBucketWebsiteInput) (req *aws.Request, output *GetBucketWebsiteOutput) {
	op := &aws.Operation{
		Name:       "GetBucketWebsite",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?website",
	}

	if input == nil {
		input = &GetBucketWebsiteInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetBucketWebsiteOutput{}
	req.Data = output
	return
}

// GetBucketWebsite Returns the website configuration for a bucket.
func (c *S3) GetBucketWebsite(input *GetBucketWebsiteInput) (*GetBucketWebsiteOutput, error) {
	req, out := c.GetBucketWebsiteRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetBucketWebsiteWithContext(ctx aws.Context, input *GetBucketWebsiteInput) (*GetBucketWebsiteOutput, error) {
	req, out := c.GetBucketWebsiteRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetObjectRequest generates a request for the GetObject operation.
func (c *S3) GetObjectRequest(input *GetObjectInput) (req *aws.Request, output *GetObjectOutput) {
	op := &aws.Operation{
		Name:       "GetObject",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &GetObjectInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetObjectOutput{}
	req.Data = output
	return
}

// GetObject Retrieves objects from KS3.
func (c *S3) GetObject(input *GetObjectInput) (*GetObjectOutput, error) {
	req, out := c.GetObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetObjectWithContext(ctx aws.Context, input *GetObjectInput) (*GetObjectOutput, error) {
	req, out := c.GetObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

func (c *S3) GetObjectToFile(input *GetObjectInput, filePath string) error {
	// Calls the API to actually download the object. Returns the result instance.
	res, err := c.GetObject(input)
	if err != nil {
		return err
	}
	return c.SaveObjectToFile(filePath, input, res)
}

func (c *S3) GetObjectToFileWithContext(ctx aws.Context, input *GetObjectInput, filePath string) error {
	// Calls the API to actually download the object. Returns the result instance.
	res, err := c.GetObjectWithContext(ctx, input)
	if err != nil {
		return err
	}
	return c.SaveObjectToFile(filePath, input, res)
}

func (c *S3) SaveObjectToFile(filePath string, input *GetObjectInput, res *GetObjectOutput) error {
	tempFilePath := filePath + TempFileSuffix
	// If the local file does not exist, create a new one. If it exists, overwrite it.
	fd, err := os.OpenFile(tempFilePath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, os.FileMode(0664))
	if err != nil {
		return err
	}

	var crc64 hash.Hash64
	if c.Config.CrcCheckEnabled {
		crc64 = crc.NewCRC(crc.CrcTable(), 0)
	}

	if c.Config.CrcCheckEnabled || input.ProgressFn != nil {
		var contentLength int64
		if res.ContentLength != nil {
			contentLength = *res.ContentLength
		}
		res.Body = aws.TeeReader(res.Body, crc64, contentLength, input.ProgressFn)
	}

	// Copy the data to the local file path.
	_, err = io.Copy(fd, res.Body)
	fd.Close()
	if err != nil {
		return err
	}

	if c.Config.CrcCheckEnabled {
		err = CheckDownloadCrc64(c, res, crc64)
		if err != nil {
			return err
		}
	}

	return os.Rename(tempFilePath, filePath)
}

// GetObjectACLRequest generates a request for the GetObjectACL operation.
func (c *S3) GetObjectACLRequest(input *GetObjectACLInput) (req *aws.Request, output *GetObjectACLOutput) {
	op := &aws.Operation{
		Name:       "GetObjectAcl",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}/{Key+}?acl",
	}

	if input == nil {
		input = &GetObjectACLInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetObjectACLOutput{}
	req.Data = output
	return
}

// GetObjectACL Returns the access control list (ACL) of an object.
func (c *S3) GetObjectACL(input *GetObjectACLInput) (*GetObjectACLOutput, error) {
	req, out := c.GetObjectACLRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetObjectACLWithContext(ctx aws.Context, input *GetObjectACLInput) (*GetObjectACLOutput, error) {
	req, out := c.GetObjectACLRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GetObjectTorrentRequest generates a request for the GetObjectTorrent operation.
func (c *S3) GetObjectTorrentRequest(input *GetObjectTorrentInput) (req *aws.Request, output *GetObjectTorrentOutput) {
	op := &aws.Operation{
		Name:       "GetObjectTorrent",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}/{Key+}?torrent",
	}

	if input == nil {
		input = &GetObjectTorrentInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetObjectTorrentOutput{}
	req.Data = output
	return
}

// GetObjectTorrent Return torrent files from a bucket.
func (c *S3) GetObjectTorrent(input *GetObjectTorrentInput) (*GetObjectTorrentOutput, error) {
	req, out := c.GetObjectTorrentRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetObjectTorrentWithContext(ctx aws.Context, input *GetObjectTorrentInput) (*GetObjectTorrentOutput, error) {
	req, out := c.GetObjectTorrentRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// HeadBucketRequest generates a request for the HeadBucket operation.
func (c *S3) HeadBucketRequest(input *HeadBucketInput) (req *aws.Request, output *HeadBucketOutput) {
	op := &aws.Operation{
		Name:       "HeadBucket",
		HTTPMethod: "HEAD",
		HTTPPath:   "/{Bucket}",
	}

	if input == nil {
		input = &HeadBucketInput{}
	}

	req = c.newRequest(op, input, output)
	output = &HeadBucketOutput{}
	req.Data = output
	return
}

// HeadBucket This operation is useful to determine if a bucket exists and you have permission
// to access it.
func (c *S3) HeadBucket(input *HeadBucketInput) (*HeadBucketOutput, error) {
	req, out := c.HeadBucketRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) HeadBucketWithContext(ctx aws.Context, input *HeadBucketInput) (*HeadBucketOutput, error) {
	req, out := c.HeadBucketRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// HeadBucketExist checks if the bucket exists.
func (c *S3) HeadBucketExist(bucket string) (bool, error) {
	var err error
	req, _ := c.HeadBucketRequest(&HeadBucketInput{
		Bucket: aws.String(bucket),
	})
	err = req.Send()
	if err == nil && req.HTTPResponse.StatusCode == 200 {
		return true, nil
	}
	return false, err
}

func (c *S3) HeadBucketExistWithContext(ctx aws.Context, bucket string) (bool, error) {
	var err error
	req, _ := c.HeadBucketRequest(&HeadBucketInput{
		Bucket: aws.String(bucket),
	})
	req.SetContext(ctx)
	err = req.Send()
	if err == nil && req.HTTPResponse.StatusCode == 200 {
		return true, nil
	}
	return false, err
}

// HeadObjectRequest generates a request for the HeadObject operation.
func (c *S3) HeadObjectRequest(input *HeadObjectInput) (req *aws.Request, output *HeadObjectOutput) {
	op := &aws.Operation{
		Name:       "HeadObject",
		HTTPMethod: "HEAD",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &HeadObjectInput{}
	}

	req = c.newRequest(op, input, output)
	output = &HeadObjectOutput{}
	req.Data = output
	return
}

// HeadObject The HEAD operation retrieves metadata from an object without returning the
// object itself. This operation is useful if you're only interested in an object's
// metadata. To use HEAD, you must have READ access to the object.
func (c *S3) HeadObject(input *HeadObjectInput) (*HeadObjectOutput, error) {
	req, out := c.HeadObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) HeadObjectWithContext(ctx aws.Context, input *HeadObjectInput) (*HeadObjectOutput, error) {
	req, out := c.HeadObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// ListBucketsRequest generates a request for the ListBuckets operation.
func (c *S3) ListBucketsRequest(input *ListBucketsInput) (req *aws.Request, output *ListBucketsOutput) {
	op := &aws.Operation{
		Name:       "ListBuckets",
		HTTPMethod: "GET",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListBucketsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &ListBucketsOutput{}
	req.Data = output
	return
}

// ListBuckets Returns a list of all buckets owned by the authenticated sender of the request.
func (c *S3) ListBuckets(input *ListBucketsInput) (*ListBucketsOutput, error) {
	req, out := c.ListBucketsRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) ListBucketsWithContext(ctx aws.Context, input *ListBucketsInput) (*ListBucketsOutput, error) {
	req, out := c.ListBucketsRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// ListMultipartUploadsRequest generates a request for the ListMultipartUploads operation.
func (c *S3) ListMultipartUploadsRequest(input *ListMultipartUploadsInput) (req *aws.Request, output *ListMultipartUploadsOutput) {
	op := &aws.Operation{
		Name:       "ListMultipartUploads",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?uploads",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"KeyMarker", "UploadIdMarker"},
			OutputTokens:    []string{"NextKeyMarker", "NextUploadIdMarker"},
			LimitToken:      "MaxUploads",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListMultipartUploadsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &ListMultipartUploadsOutput{}
	req.Data = output
	return
}

// ListMultipartUploads This operation lists in-progress multipart uploads.
func (c *S3) ListMultipartUploads(input *ListMultipartUploadsInput) (*ListMultipartUploadsOutput, error) {
	req, out := c.ListMultipartUploadsRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) ListMultipartUploadsWithContext(ctx aws.Context, input *ListMultipartUploadsInput) (*ListMultipartUploadsOutput, error) {
	req, out := c.ListMultipartUploadsRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

func (c *S3) ListMultipartUploadsPages(input *ListMultipartUploadsInput, fn func(p *ListMultipartUploadsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListMultipartUploadsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListMultipartUploadsOutput), lastPage)
	})
}

// ListObjectVersionsRequest generates a request for the ListObjectVersions operation.
func (c *S3) ListObjectVersionsRequest(input *ListObjectVersionsInput) (req *aws.Request, output *ListObjectVersionsOutput) {
	op := &aws.Operation{
		Name:       "ListObjectVersions",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}?versions",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"KeyMarker", "VersionIdMarker"},
			OutputTokens:    []string{"NextKeyMarker", "NextVersionIdMarker"},
			LimitToken:      "MaxKeys",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListObjectVersionsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &ListObjectVersionsOutput{}
	req.Data = output
	return
}

// ListObjectVersions Returns metadata about all the versions of objects in a bucket.
func (c *S3) ListObjectVersions(input *ListObjectVersionsInput) (*ListObjectVersionsOutput, error) {
	req, out := c.ListObjectVersionsRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) ListObjectVersionsWithContext(ctx aws.Context, input *ListObjectVersionsInput) (*ListObjectVersionsOutput, error) {
	req, out := c.ListObjectVersionsRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

func (c *S3) ListObjectVersionsPages(input *ListObjectVersionsInput, fn func(p *ListObjectVersionsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListObjectVersionsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListObjectVersionsOutput), lastPage)
	})
}

// ListObjectsRequest generates a request for the ListObjects operation.
func (c *S3) ListObjectsRequest(input *ListObjectsInput) (req *aws.Request, output *ListObjectsOutput) {
	op := &aws.Operation{
		Name:       "ListObjects",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"NextMarker || Contents[-1].Key"},
			LimitToken:      "MaxKeys",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListObjectsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &ListObjectsOutput{}
	req.Data = output
	return
}

// ListObjects Returns some or all (up to 1000) of the objects in a bucket. You can use
// the request parameters as selection criteria to return a subset of the objects
// in a bucket.
func (c *S3) ListObjects(input *ListObjectsInput) (*ListObjectsOutput, error) {
	req, out := c.ListObjectsRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) ListObjectsWithContext(ctx aws.Context, input *ListObjectsInput) (*ListObjectsOutput, error) {
	req, out := c.ListObjectsRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

func (c *S3) ListObjectsPages(input *ListObjectsInput, fn func(p *ListObjectsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListObjectsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListObjectsOutput), lastPage)
	})
}

// ListPartsRequest generates a request for the ListParts operation.
func (c *S3) ListPartsRequest(input *ListPartsInput) (req *aws.Request, output *ListPartsOutput) {
	op := &aws.Operation{
		Name:       "ListParts",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}/{Key+}",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"PartNumberMarker"},
			OutputTokens:    []string{"NextPartNumberMarker"},
			LimitToken:      "MaxParts",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListPartsInput{}
	}

	req = c.newRequest(op, input, output)
	output = &ListPartsOutput{}
	req.Data = output
	return
}

// ListParts Lists the parts that have been uploaded for a specific multipart upload.
func (c *S3) ListParts(input *ListPartsInput) (*ListPartsOutput, error) {
	req, out := c.ListPartsRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) ListPartsWithContext(ctx aws.Context, input *ListPartsInput) (*ListPartsOutput, error) {
	req, out := c.ListPartsRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

func (c *S3) ListPartsPages(input *ListPartsInput, fn func(p *ListPartsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListPartsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListPartsOutput), lastPage)
	})
}

// PutBucketACLRequest generates a request for the PutBucketACL operation.
func (c *S3) PutBucketACLRequest(input *PutBucketACLInput) (req *aws.Request, output *PutBucketACLOutput) {
	op := &aws.Operation{
		Name:       "PutBucketAcl",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?acl",
	}

	if input == nil {
		input = &PutBucketACLInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketACLOutput{}
	req.Data = output
	return
}

// PutBucketACL Sets the permissions on a bucket using access control lists (ACL).
func (c *S3) PutBucketACL(input *PutBucketACLInput) (*PutBucketACLOutput, error) {
	req, out := c.PutBucketACLRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketACLWithContext(ctx aws.Context, input *PutBucketACLInput) (*PutBucketACLOutput, error) {
	req, out := c.PutBucketACLRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketLoggingRequest generates a request for the PutBucketLogging operation.
func (c *S3) PutBucketLoggingRequest(input *PutBucketLoggingInput) (req *aws.Request, output *PutBucketLoggingOutput) {
	op := &aws.Operation{
		Name:       "PutBucketLogging",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?logging",
	}

	if input == nil {
		input = &PutBucketLoggingInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketLoggingOutput{}
	req.Data = output
	return
}

// PutBucketLogging Set the logging parameters for a bucket and to specify permissions for who
// can view and modify the logging parameters. To set the logging status of
// a bucket, you must be the bucket owner.
func (c *S3) PutBucketLogging(input *PutBucketLoggingInput) (*PutBucketLoggingOutput, error) {
	req, out := c.PutBucketLoggingRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketLoggingWithContext(ctx aws.Context, input *PutBucketLoggingInput) (*PutBucketLoggingOutput, error) {
	req, out := c.PutBucketLoggingRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketNotificationRequest generates a request for the PutBucketNotification operation.
func (c *S3) PutBucketNotificationRequest(input *PutBucketNotificationInput) (req *aws.Request, output *PutBucketNotificationOutput) {
	op := &aws.Operation{
		Name:       "PutBucketNotification",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?notification",
	}

	if input == nil {
		input = &PutBucketNotificationInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketNotificationOutput{}
	req.Data = output
	return
}

// PutBucketNotification Deprecated, see the PutBucketNotificationConfiguraiton operation.
func (c *S3) PutBucketNotification(input *PutBucketNotificationInput) (*PutBucketNotificationOutput, error) {
	req, out := c.PutBucketNotificationRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketNotificationWithContext(ctx aws.Context, input *PutBucketNotificationInput) (*PutBucketNotificationOutput, error) {
	req, out := c.PutBucketNotificationRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketNotificationConfigurationRequest generates a request for the PutBucketNotificationConfiguration operation.
func (c *S3) PutBucketNotificationConfigurationRequest(input *PutBucketNotificationConfigurationInput) (req *aws.Request, output *PutBucketNotificationConfigurationOutput) {
	op := &aws.Operation{
		Name:       "PutBucketNotificationConfiguration",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?notification",
	}

	if input == nil {
		input = &PutBucketNotificationConfigurationInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketNotificationConfigurationOutput{}
	req.Data = output
	return
}

// PutBucketNotificationConfiguration Enables notifications of specified events for a bucket.
func (c *S3) PutBucketNotificationConfiguration(input *PutBucketNotificationConfigurationInput) (*PutBucketNotificationConfigurationOutput, error) {
	req, out := c.PutBucketNotificationConfigurationRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketNotificationConfigurationWithContext(ctx aws.Context, input *PutBucketNotificationConfigurationInput) (*PutBucketNotificationConfigurationOutput, error) {
	req, out := c.PutBucketNotificationConfigurationRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketPolicyRequest generates a request for the PutBucketPolicy operation.
func (c *S3) PutBucketPolicyRequest(input *PutBucketPolicyInput) (req *aws.Request, output *PutBucketPolicyOutput) {
	op := &aws.Operation{
		Name:       "PutBucketPolicy",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?policy",
	}

	if input == nil {
		input = &PutBucketPolicyInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketPolicyOutput{}
	req.Data = output
	return
}

// PutBucketPolicy Replaces a policy on a bucket. If the bucket already has a policy, the one
// in this request completely replaces it.
func (c *S3) PutBucketPolicy(input *PutBucketPolicyInput) (*PutBucketPolicyOutput, error) {
	req, out := c.PutBucketPolicyRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketPolicyWithContext(ctx aws.Context, input *PutBucketPolicyInput) (*PutBucketPolicyOutput, error) {
	req, out := c.PutBucketPolicyRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketRequestPaymentRequest generates a request for the PutBucketRequestPayment operation.
func (c *S3) PutBucketRequestPaymentRequest(input *PutBucketRequestPaymentInput) (req *aws.Request, output *PutBucketRequestPaymentOutput) {
	op := &aws.Operation{
		Name:       "PutBucketRequestPayment",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?requestPayment",
	}

	if input == nil {
		input = &PutBucketRequestPaymentInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketRequestPaymentOutput{}
	req.Data = output
	return
}

// PutBucketRequestPayment Sets the request payment configuration for a bucket. By default, the bucket
// owner pays for downloads from the bucket. This configuration parameter enables
// the bucket owner (only) to specify that the person requesting the download
// will be charged for the download.
func (c *S3) PutBucketRequestPayment(input *PutBucketRequestPaymentInput) (*PutBucketRequestPaymentOutput, error) {
	req, out := c.PutBucketRequestPaymentRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketRequestPaymentWithContext(ctx aws.Context, input *PutBucketRequestPaymentInput) (*PutBucketRequestPaymentOutput, error) {
	req, out := c.PutBucketRequestPaymentRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketVersioningRequest generates a request for the PutBucketVersioning operation.
func (c *S3) PutBucketVersioningRequest(input *PutBucketVersioningInput) (req *aws.Request, output *PutBucketVersioningOutput) {
	op := &aws.Operation{
		Name:       "PutBucketVersioning",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?versioning",
	}

	if input == nil {
		input = &PutBucketVersioningInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketVersioningOutput{}
	req.Data = output
	return
}

// PutBucketVersioning Sets the versioning state of an existing bucket. To set the versioning state,
// you must be the bucket owner.
func (c *S3) PutBucketVersioning(input *PutBucketVersioningInput) (*PutBucketVersioningOutput, error) {
	req, out := c.PutBucketVersioningRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketVersioningWithContext(ctx aws.Context, input *PutBucketVersioningInput) (*PutBucketVersioningOutput, error) {
	req, out := c.PutBucketVersioningRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutBucketWebsiteRequest generates a request for the PutBucketWebsite operation.
func (c *S3) PutBucketWebsiteRequest(input *PutBucketWebsiteInput) (req *aws.Request, output *PutBucketWebsiteOutput) {
	op := &aws.Operation{
		Name:       "PutBucketWebsite",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}?website",
	}

	if input == nil {
		input = &PutBucketWebsiteInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutBucketWebsiteOutput{}
	req.Data = output
	return
}

type metadataGeneratePresignedUrlInput struct {
	SDKShapeTraits bool `type:"structure" payload:"GeneratePresignedUrlInput"`
}
type GeneratePresignedUrlInput struct {

	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	ContentMd5 *string `location:"header" locationName:"Content-Md5" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	TrafficLimit *int64 `location:"querystring" locationName:"x-kss-traffic-limit"  type:"integer"`

	HTTPMethod HTTPMethod `locationName:"HTTPMethod" type:"string" required:"true"`

	// The date and time at which the object is no longer cacheable.
	Expires int64 `locationName:"Expires" type:"integer" required:"true"`

	// Sets the Cache-Control header of the response.
	ResponseCacheControl *string `location:"querystring" locationName:"response-cache-control" type:"string"`

	// Sets the Content-Disposition header of the response
	ResponseContentDisposition *string `location:"querystring" locationName:"response-content-disposition" type:"string"`

	// Sets the Content-Encoding header of the response.
	ResponseContentEncoding *string `location:"querystring" locationName:"response-content-encoding" type:"string"`

	// Sets the Content-Language header of the response.
	ResponseContentLanguage *string `location:"querystring" locationName:"response-content-language" type:"string"`

	// Sets the Content-Type header of the response.
	ResponseContentType *string `location:"querystring" locationName:"response-content-type" type:"string"`

	// Sets the Expires header of the response.
	ResponseExpires *time.Time `location:"querystring" locationName:"response-expires" type:"timestamp" timestampFormat:"iso8601"`

	// Deprecated, use ExtendHeaders instead.
	Headers map[string]*string `location:"extendHeaders" type:"map"`

	// Deprecated, use ExtendQueryParams instead.
	Parameters map[string]*string `location:"extendQueryParams" type:"map"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGeneratePresignedUrlInput `json:"-" xml:"-"`
}
type GeneratePresignedUrlOutput struct {
	url *string
}

// PutBucketWebsite Set the website configuration for a bucket.
func (c *S3) PutBucketWebsite(input *PutBucketWebsiteInput) (*PutBucketWebsiteOutput, error) {
	req, out := c.PutBucketWebsiteRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutBucketWebsiteWithContext(ctx aws.Context, input *PutBucketWebsiteInput) (*PutBucketWebsiteOutput, error) {
	req, out := c.PutBucketWebsiteRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// PutObjectRequest generates a request for the PutObject operation.
func (c *S3) PutObjectRequest(input *PutObjectInput) (req *aws.Request, output *PutObjectOutput) {
	op := &aws.Operation{
		Name:       "PutObject",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &PutObjectInput{}
	}

	req = c.newRequest(op, input, output)
	if c.Config.CrcCheckEnabled {
		req.Handlers.CheckCrc64.PushBack(CheckUploadCrc64)
	}
	if input.ProgressFn != nil {
		req.ProgressFn = input.ProgressFn
	}
	output = &PutObjectOutput{}
	req.Data = output
	return
}

// PutObject Adds an object to a bucket.
func (c *S3) PutObject(input *PutObjectInput) (*PutObjectOutput, error) {
	req, out := c.PutObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutObjectWithContext(ctx aws.Context, input *PutObjectInput) (*PutObjectOutput, error) {
	req, out := c.PutObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

func (c *S3) PutReaderRequest(input *PutReaderInput) (req *aws.Request, output *PutObjectOutput) {
	op := &aws.Operation{
		Name:       "PutObject",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &PutReaderInput{}
	}
	input.Body = &Body{io.NopCloser(input.Body)}

	req = c.newRequest(op, input, output)
	if c.Config.CrcCheckEnabled {
		req.Handlers.CheckCrc64.PushBack(CheckUploadCrc64)
	}
	if input.ProgressFn != nil {
		req.ProgressFn = input.ProgressFn
	}
	output = &PutObjectOutput{}
	req.Data = output
	return
}

// PutReader Adds an object to a bucket.
func (c *S3) PutReader(input *PutReaderInput) (*PutObjectOutput, error) {
	req, out := c.PutReaderRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutReaderWithContext(ctx aws.Context, input *PutReaderInput) (*PutObjectOutput, error) {
	req, out := c.PutReaderRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// GeneratePresignedUrl generates a presigned url for the object
func (c *S3) GeneratePresignedUrl(input *GeneratePresignedUrlInput) (url string, err error) {
	op := &aws.Operation{
		HTTPMethod: string(input.HTTPMethod),
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &GeneratePresignedUrlInput{}
	}

	if input.ExtendHeaders == nil {
		input.ExtendHeaders = input.Headers
	}

	if input.ExtendQueryParams == nil {
		input.ExtendQueryParams = input.Parameters
	}

	output := &GeneratePresignedUrlOutput{}
	req := c.newRequest(op, input, output)

	aws.ValidateParameters(req)
	if req.Error != nil {
		return "", req.Error
	}

	if string(input.HTTPMethod) == "" {
		return "", apierr.New("InvalidParameter", "missing required parameter: HTTPMethod", nil)
	}

	if input.Expires <= 0 {
		return "", apierr.New("InvalidParameter", "Expires is required and must bigger than 0", nil)
	}

	if IsV4Signature(c.Config.SignerVersion) {
		if input.Expires > 604800 {
			return "", apierr.New("InvalidParameter", "Expires must between 1 and 604800 in V4 signature", nil)
		}
		req.ExpireTime = input.Expires
	} else {
		req.ExpireTime = input.Expires + time.Now().Unix()
	}
	req.Sign()

	return req.HTTPRequest.URL.String(), nil
}

// GeneratePresignedUrlInput generates a presigned url for the object
// Deprecated: Use GeneratePresignedUrl instead.
func (c *S3) GeneratePresignedUrlInput(input *GeneratePresignedUrlInput) (url string) {
	opGeneratePresigned := &aws.Operation{
		HTTPMethod: string(input.HTTPMethod),
		HTTPPath:   "/{Bucket}/{Key+}",
	}
	output := &GeneratePresignedUrlOutput{}
	req := c.newRequest(opGeneratePresigned, input, output)
	now := time.Now().Unix()
	if c.Config.SignerVersion == "V4" || c.Config.SignerVersion == "V4_UNSIGNED_PAYLOAD_SIGNER" {
		req.ExpireTime = input.Expires
	} else {
		req.ExpireTime = input.Expires + now
	}
	req.Sign()
	return req.HTTPRequest.URL.String()
}

func (c *S3) PutObjectPreassignedInput(input *PutObjectInput) (*http.Request, error) {
	req, _ := c.PutObjectRequest(input)
	err := req.Sign()
	return req.HTTPRequest, err
}

// PutObjectACLRequest generates a request for the PutObjectACL operation.
func (c *S3) PutObjectACLRequest(input *PutObjectACLInput) (req *aws.Request, output *PutObjectACLOutput) {
	op := &aws.Operation{
		Name:       "PutObjectAcl",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}?acl",
	}

	if input == nil {
		input = &PutObjectACLInput{}
	}

	req = c.newRequest(op, input, output)
	output = &PutObjectACLOutput{}
	req.Data = output
	return
}

// PutObjectACL uses the acl subresource to set the access control list (ACL) permissions
// for an object that already exists in a bucket
func (c *S3) PutObjectACL(input *PutObjectACLInput) (*PutObjectACLOutput, error) {
	req, out := c.PutObjectACLRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutObjectACLWithContext(ctx aws.Context, input *PutObjectACLInput) (*PutObjectACLOutput, error) {
	req, out := c.PutObjectACLRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// RestoreObjectRequest generates a request for the RestoreObject operation.
func (c *S3) RestoreObjectRequest(input *RestoreObjectInput) (req *aws.Request, output *RestoreObjectOutput) {
	op := &aws.Operation{
		Name:       "RestoreObject",
		HTTPMethod: "POST",
		HTTPPath:   "/{Bucket}/{Key+}?restore",
	}

	if input == nil {
		input = &RestoreObjectInput{}
	}

	req = c.newRequest(op, input, output)
	output = &RestoreObjectOutput{}
	req.Data = output
	return
}

func (c *S3) RestoreObject(input *RestoreObjectInput) (*RestoreObjectOutput, error) {
	req, out := c.RestoreObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) RestoreObjectWithContext(ctx aws.Context, input *RestoreObjectInput) (*RestoreObjectOutput, error) {
	req, out := c.RestoreObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// UploadPartRequest generates a request for the UploadPart operation.
func (c *S3) UploadPartRequest(input *UploadPartInput) (req *aws.Request, output *UploadPartOutput) {
	op := &aws.Operation{
		Name:       "UploadPart",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &UploadPartInput{}
	}

	req = c.newRequest(op, input, output)
	if c.Config.CrcCheckEnabled {
		req.Handlers.CheckCrc64.PushBack(CheckUploadCrc64)
	}
	if input.ProgressFn != nil {
		req.ProgressFn = input.ProgressFn
	}
	output = &UploadPartOutput{}
	req.Data = output
	return
}

// UploadPart Uploads a part in a multipart upload.
//
// Note: After you initiate multipart upload and upload one or more parts,
// you must either complete or abort multipart upload in order to stop getting
// charged for storage of the uploaded parts. Only after you either complete
// or abort multipart upload, Amazon S3 frees up the parts storage and stops
// charging you for the parts storage.
func (c *S3) UploadPart(input *UploadPartInput) (*UploadPartOutput, error) {
	req, out := c.UploadPartRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) UploadPartWithContext(ctx aws.Context, input *UploadPartInput) (*UploadPartOutput, error) {
	req, out := c.UploadPartRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

// UploadPartCopyRequest generates a request for the UploadPartCopy operation.
func (c *S3) UploadPartCopyRequest(input *UploadPartCopyInput) (req *aws.Request, output *UploadPartCopyOutput) {
	op := &aws.Operation{
		Name:       "UploadPartCopy",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}",
	}

	if input == nil {
		input = &UploadPartCopyInput{}
	}

	// URL encode the copy source
	if input.CopySource == nil {
		input.CopySource = aws.String(BuildCopySource(input.SourceBucket, input.SourceKey))
	}
	req = c.newRequest(op, input, output)
	output = &UploadPartCopyOutput{}
	req.Data = output
	return
}

// UploadPartCopy Uploads a part by copying data from an existing object as data source.
func (c *S3) UploadPartCopy(input *UploadPartCopyInput) (*UploadPartCopyOutput, error) {
	req, out := c.UploadPartCopyRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) UploadPartCopyWithContext(ctx aws.Context, input *UploadPartCopyInput) (*UploadPartCopyOutput, error) {
	req, out := c.UploadPartCopyRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

type AbortMultipartUploadInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataAbortMultipartUploadInput `json:"-" xml:"-"`
}

type metadataAbortMultipartUploadInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type AbortMultipartUploadOutput struct {
	// If present, indicates that the requester was successfully charged for the request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataAbortMultipartUploadOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataAbortMultipartUploadOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type AccessControlPolicy struct {
	// A list of grants.
	Grants []*Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	Owner *Owner `type:"structure"`

	metadataAccessControlPolicy `json:"-" xml:"-"`
}

type metadataAccessControlPolicy struct {
	SDKShapeTraits bool `type:"structure"`
}

type Bucket struct {
	// Date the bucket was created.
	CreationDate *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// The name of the bucket.
	Name *string `type:"string"`

	Region *string `type:"string"`

	Type *string `type:"string"`

	// Bucket visit type, NORMAL is the standard type, FREQUENTLIST is the high-frequency enumeration type.
	VisitType *string `type:"string"`

	// The bucket data redundancy type.
	DataRedundancyType *string `type:"string"`

	metadataBucket `json:"-" xml:"-"`
}

type metadataBucket struct {
	SDKShapeTraits bool `type:"structure"`
}

type BucketLoggingStatus struct {
	LoggingEnabled *LoggingEnabled `type:"structure"`

	metadataBucketLoggingStatus `json:"-" xml:"-"`
}

type metadataBucketLoggingStatus struct {
	SDKShapeTraits bool `type:"structure"`
}

type CloudFunctionConfiguration struct {
	CloudFunction *string `type:"string"`

	// Bucket event for which to send notifications.
	Event *string `type:"string"`

	Events []*string `locationName:"Event" type:"list" flattened:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	InvocationRole *string `type:"string"`

	metadataCloudFunctionConfiguration `json:"-" xml:"-"`
}

type metadataCloudFunctionConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type CommonPrefix struct {
	Prefix *string `type:"string"`

	metadataCommonPrefix `json:"-" xml:"-"`
}

type metadataCommonPrefix struct {
	SDKShapeTraits bool `type:"structure"`
}

type CompleteMultipartUploadInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	MultipartUpload *CompletedMultipartUpload `locationName:"CompleteMultipartUpload" type:"structure"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Specifies whether the object is forbidden to overwrite.
	ForbidOverwrite *bool `location:"header" locationName:"x-amz-forbid-overwrite" type:"boolean"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataCompleteMultipartUploadInput `json:"-" xml:"-"`
}

type metadataCompleteMultipartUploadInput struct {
	SDKShapeTraits bool `type:"structure" payload:"MultipartUpload"`
}

type CompleteMultipartUploadOutput struct {
	Bucket *string `type:"string"`

	// Entity tag of the object.
	ETag *string `type:"string"`

	// If the object expiration is configured, this will contain the expiration
	// date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	Key *string `type:"string"`

	Location *string `type:"string"`

	ChecksumCRC64ECMA *string `type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in KS3, eg: AES256.
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	metadataCompleteMultipartUploadOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataCompleteMultipartUploadOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CompletedMultipartUpload struct {
	Parts []*CompletedPart `locationName:"Part" type:"list" flattened:"true"`

	metadataCompletedMultipartUpload `json:"-" xml:"-"`
}

type metadataCompletedMultipartUpload struct {
	SDKShapeTraits bool `type:"structure"`
}

type CompletedPart struct {
	// Entity tag returned when the part was uploaded.
	ETag *string `type:"string"`

	// Part number that identifies the part.
	PartNumber *int64 `type:"integer"`

	// CRC64 value of a single part
	ChecksumCRC64ECMA *string `type:"string"`

	metadataCompletedPart `json:"-" xml:"-"`
}

type metadataCompletedPart struct {
	SDKShapeTraits bool `type:"structure"`
}

type Condition struct {
	// The HTTP error code when the redirect is applied. In the event of an error,
	// if the error code equals this value, then the specified redirect is applied.
	// Required when parent element Condition is specified and sibling KeyPrefixEquals
	// is not specified. If both are specified, then both must be true for the redirect
	// to be applied.
	HTTPErrorCodeReturnedEquals *string `locationName:"HttpErrorCodeReturnedEquals" type:"string"`

	// The object key name prefix when the redirect is applied. For example, to
	// redirect requests for ExamplePage.html, the key prefix will be ExamplePage.html.
	// To redirect request for all pages with the prefix docs/, the key prefix will
	// be /docs, which identifies all objects in the docs/ folder. Required when
	// the parent element Condition is specified and sibling HttpErrorCodeReturnedEquals
	// is not specified. If both conditions are specified, both must be true for
	// the redirect to be applied.
	KeyPrefixEquals *string `type:"string"`

	metadataCondition `json:"-" xml:"-"`
}

type metadataCondition struct {
	SDKShapeTraits bool `type:"structure"`
}

type CopyObjectInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	SourceBucket *string `location:"uri" locationName:"sourceBucket" type:"string"`

	SourceKey *string `location:"uri" locationName:"sourceKey" type:"string"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The name of the source bucket and key name of the source object, separated
	// by a slash (/). Must be URL-encoded.
	CopySource *string `location:"header" locationName:"x-amz-copy-source" type:"string" required:"true"`

	// Copies the object if its entity tag (ETag) matches the specified tag.
	CopySourceIfMatch *string `location:"header" locationName:"x-amz-copy-source-if-match" type:"string"`

	// Copies the object if it has been modified since the specified time.
	CopySourceIfModifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-modified-since" type:"timestamp" timestampFormat:"rfc822"`

	// Copies the object if its entity tag (ETag) is different from the specified ETag.
	CopySourceIfNoneMatch *string `location:"header" locationName:"x-amz-copy-source-if-none-match" type:"string"`

	// Copies the object if it hasn't been modified since the specified time.
	CopySourceIfUnmodifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-unmodified-since" type:"timestamp" timestampFormat:"rfc822"`

	// Specifies the algorithm to use when decrypting the source object (e.g., AES256).
	CopySourceSSECustomerAlgorithm *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt
	// the source object. The encryption key provided in this header must be one
	// that was used when the source object was created.
	CopySourceSSECustomerKey *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	CopySourceSSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key-MD5" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Specifies whether the metadata is copied from the source object or replaced
	// with metadata provided in the request.
	MetadataDirective *string `location:"header" locationName:"x-amz-metadata-directive" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	// Specifies the object tag of the object. Multiple tags can be set at the same time, such as: TagA=A&TagB=B.
	// Note: Key and Value need to be URL-encoded first. If an item does not have "=", the Value is considered to be an empty string.
	Tagging *string `location:"header" locationName:"x-amz-tagging" type:"string"`

	// Specifies how to set the object tag of the target object.
	// Default value: COPY
	// Valid values:
	// COPY (default value): Copies the object tag of the source object to the target object.
	// REPLACE: Ignores the object tag of the source object and directly uses the object tag specified in the request.
	TaggingDirective *string `location:"header" locationName:"x-amz-tagging-directive" type:"string"`

	// Specifies whether the object is forbidden to overwrite.
	ForbidOverwrite *bool `location:"header" locationName:"x-amz-forbid-overwrite" type:"boolean"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataCopyObjectInput `json:"-" xml:"-"`
}

type metadataCopyObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CopyObjectOutput struct {
	CopyObjectResult *CopyObjectResult `type:"structure"`

	CopySourceVersionID *string `location:"header" locationName:"x-amz-copy-source-version-id" type:"string"`

	// If the object expiration is configured, the response includes this header.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	metadataCopyObjectOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataCopyObjectOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"CopyObjectResult"`
}

type CopyObjectResult struct {
	ETag *string `type:"string"`

	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// CRC64 value of a single part
	ChecksumCRC64ECMA *string `type:"string"`

	metadataCopyObjectResult `json:"-" xml:"-"`
}

type metadataCopyObjectResult struct {
	SDKShapeTraits bool `type:"structure"`
}

type CopyPartResult struct {
	// Entity tag of the object.
	ETag *string `type:"string"`

	// Date and time at which the object was uploaded.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// CRC64 value of a single part
	ChecksumCRC64ECMA *string `type:"string"`

	metadataCopyPartResult `json:"-" xml:"-"`
}

type metadataCopyPartResult struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateBucketConfiguration struct {
	// Specifies the region where the bucket will be created. If you don't specify
	// a region, the bucket will be created in US Standard.
	LocationConstraint *string `type:"string"`

	// The bucket data redundancy type.
	// Default value: LRS
	// Valid value: LRS丨ZRS
	// LRS: local redundancy storage
	// ZRS: zone redundancy storage
	DataRedundancyType *string `type:"string"`

	metadataCreateBucketConfiguration `json:"-" xml:"-"`
}

type metadataCreateBucketConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateBucketInput struct {
	// The canned ACL to apply to the bucket.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	ProjectId *string `location:"uri" locationName:"ProjectId" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	CreateBucketConfiguration *CreateBucketConfiguration `locationName:"CreateBucketConfiguration" type:"structure" xmlURI:"http://s3.amazonaws.com/doc/2006-03-01/"`

	// Allows grantee the read, write, read ACP, and write ACP permissions on the
	// bucket.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to list the objects in the bucket.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the bucket ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to create, overwrite, and delete any object in the bucket.
	GrantWrite *string `location:"header" locationName:"x-amz-grant-write" type:"string"`

	// Allows grantee to write the ACL for the applicable bucket.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	BucketType *string `location:"header" locationName:"x-amz-bucket-type" type:"string"`

	// Specify the bucket visit type.
	BucketVisitType *string `location:"header" locationName:"x-amz-bucket-visit-type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	MetadataCreateBucketInput `json:"-" xml:"-"`
}

type MetadataCreateBucketInput struct {
	SDKShapeTraits bool `type:"structure" payload:"CreateBucketConfiguration"`
}

type CreateBucketOutput struct {
	Location *string `location:"header" locationName:"Location" type:"string"`

	metadataCreateBucketOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataCreateBucketOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateMultipartUploadInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	// Specifies the object tag of the object. Multiple tags can be set at the same time, such as: TagA=A&TagB=B.
	// Note: Key and Value need to be URL-encoded first. If an item does not have "=", the Value is considered to be an empty string.
	Tagging *string `location:"header" locationName:"x-amz-tagging" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	// Specifies whether the object is forbidden to overwrite.
	ForbidOverwrite *bool `location:"header" locationName:"x-amz-forbid-overwrite" type:"boolean"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataCreateMultipartUploadInput `json:"-" xml:"-"`
}

type metadataCreateMultipartUploadInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateMultipartUploadOutput struct {
	// Name of the bucket to which the multipart upload was initiated.
	Bucket *string `locationName:"Bucket" type:"string"`

	// Object key for which the multipart upload was initiated.
	Key *string `type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// ID for the initiated multipart upload.
	UploadID *string `locationName:"UploadId" type:"string"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	metadataCreateMultipartUploadOutput `json:"-" xml:"-"`
}

type metadataCreateMultipartUploadOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type Delete struct {
	Objects []*ObjectIdentifier `locationName:"Object" type:"list" flattened:"true" required:"true"`

	// Element to enable quiet mode for the request. When you add this element,
	// you must set its value to true.
	Quiet *bool `type:"boolean"`

	metadataDelete `json:"-" xml:"-"`
}

type metadataDelete struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataDeleteBucketInput `json:"-" xml:"-"`
}

type metadataDeleteBucketInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketOutput struct {
	metadataDeleteBucketOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataDeleteBucketOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketPolicyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataDeleteBucketPolicyInput `json:"-" xml:"-"`
}

type metadataDeleteBucketPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketPolicyOutput struct {
	metadataDeleteBucketPolicyOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataDeleteBucketPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketWebsiteInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataDeleteBucketWebsiteInput `json:"-" xml:"-"`
}

type metadataDeleteBucketWebsiteInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteBucketWebsiteOutput struct {
	metadataDeleteBucketWebsiteOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataDeleteBucketWebsiteOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteMarkerEntry struct {
	// Specifies whether the object is (true) or is not (false) the latest version
	// of an object.
	IsLatest *bool `type:"boolean"`

	// The object key.
	Key *string `type:"string"`

	// Date and time the object was last modified.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	Owner *Owner `type:"structure"`

	// Version ID of an object.
	VersionID *string `locationName:"VersionId" type:"string"`

	metadataDeleteMarkerEntry `json:"-" xml:"-"`
}

type metadataDeleteMarkerEntry struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// The concatenation of the authentication device's serial number, a space,
	// and the value that is displayed on your authentication device.
	MFA *string `location:"header" locationName:"x-amz-mfa" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataDeleteObjectInput `json:"-" xml:"-"`
}

type DeleteBucketPrefixInput struct {
	// The name of the bucket.
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`
	// Prefix of the object.
	Prefix *string `type:"string"  required:"true"`
	// The max number of each list.
	MaxKeys *int64 `type:"integer" required:"true"`
	// Is return the deletion result.
	IsReTurnResults *bool `type:"boolean" required:"true"`
}

type metadataDeleteObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectOutput struct {
	// Specifies whether the versioned object that was permanently deleted was (true)
	// or was not (false) a delete marker.
	DeleteMarker *bool `location:"header" locationName:"x-amz-delete-marker" type:"boolean"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// Returns the version ID of the delete marker created as a result of the DELETE
	// operation.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	metadataDeleteObjectOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataDeleteObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Delete *Delete `locationName:"Delete" type:"structure" required:"true"`

	IsReTurnResults *bool `type:"boolean"  required:"true"`

	// The concatenation of the authentication device's serial number, a space,
	// and the value that is displayed on your authentication device.
	MFA *string `location:"header" locationName:"x-amz-mfa" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataDeleteObjectsInput `json:"-" xml:"-"`
}

type metadataDeleteObjectsInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Delete"`
}

type DeleteObjectsOutput struct {
	Deleted []*DeletedObject `type:"list" flattened:"true"`

	Errors []*Error `locationName:"Error" type:"list" flattened:"true"`

	ErrorsCount *int64 `locationName:"ErrorsCount" type:"integer"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataDeleteObjectsOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataDeleteObjectsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeletedObject struct {
	DeleteMarker *bool `type:"boolean"`

	DeleteMarkerVersionID *string `locationName:"DeleteMarkerVersionId" type:"string"`

	Key *string `type:"string"`

	VersionID *string `locationName:"VersionId" type:"string"`

	metadataDeletedObject `json:"-" xml:"-"`
}

type metadataDeletedObject struct {
	SDKShapeTraits bool `type:"structure"`
}

type Error struct {
	Code *string `type:"string"`

	Key *string `type:"string"`

	Message *string `type:"string"`

	VersionID *string `locationName:"VersionId" type:"string"`

	metadataError `json:"-" xml:"-"`
}

type metadataError struct {
	SDKShapeTraits bool `type:"structure"`
}

type ErrorDocument struct {
	// The object key name to use when a 4XX class error occurs.
	Key *string `type:"string" required:"true"`

	metadataErrorDocument `json:"-" xml:"-"`
}

type metadataErrorDocument struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketACLInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketACLInput `json:"-" xml:"-"`
}

type metadataGetBucketACLInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketACLOutput struct {
	// A list of grants.
	Grants []*Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	Owner *Owner `type:"structure"`

	metadataGetBucketACLOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLocationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketLocationInput `json:"-" xml:"-"`
}

type metadataGetBucketLocationInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLocationOutput struct {
	LocationConstraint *string `type:"string"`

	metadataGetBucketLocationOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketLocationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLoggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketLoggingInput `json:"-" xml:"-"`
}

type metadataGetBucketLoggingInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketLoggingOutput struct {
	LoggingEnabled *LoggingEnabled `type:"structure"`

	metadataGetBucketLoggingOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketLoggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketNotificationConfigurationRequest struct {
	// Name of the buket to get the notification configuration for.
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	metadataGetBucketNotificationConfigurationRequest `json:"-" xml:"-"`
}

type metadataGetBucketNotificationConfigurationRequest struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketPolicyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketPolicyInput `json:"-" xml:"-"`
}

type metadataGetBucketPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketPolicyOutput struct {
	// The bucket policy as a JSON document.
	Policy *string `type:"string"`

	metadataGetBucketPolicyOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketPolicyOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Policy"`
}

type GetBucketRequestPaymentInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketRequestPaymentInput `json:"-" xml:"-"`
}

type metadataGetBucketRequestPaymentInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketRequestPaymentOutput struct {
	// Specifies who pays for the download and request fees.
	Payer *string `type:"string"`

	metadataGetBucketRequestPaymentOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketRequestPaymentOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketVersioningInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketVersioningInput `json:"-" xml:"-"`
}

type metadataGetBucketVersioningInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketVersioningOutput struct {
	// Specifies whether MFA delete is enabled in the bucket versioning configuration.
	// This element is only returned if the bucket has been configured with MFA
	// delete. If the bucket has never been so configured, this element is not returned.
	MFADelete *string `locationName:"MfaDelete" type:"string"`

	// The versioning state of the bucket.
	Status *string `type:"string"`

	metadataGetBucketVersioningOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketVersioningOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketWebsiteInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetBucketWebsiteInput `json:"-" xml:"-"`
}

type metadataGetBucketWebsiteInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetBucketWebsiteOutput struct {
	ErrorDocument *ErrorDocument `type:"structure"`

	IndexDocument *IndexDocument `type:"structure"`

	RedirectAllRequestsTo *RedirectAllRequestsTo `type:"structure"`

	RoutingRules []*RoutingRule `locationNameList:"RoutingRule" type:"list"`

	metadataGetBucketWebsiteOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetBucketWebsiteOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectACLInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetObjectACLInput `json:"-" xml:"-"`
}

type metadataGetObjectACLInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectACLOutput struct {
	// A list of grants.
	Grants []*Grant `locationName:"AccessControlList" locationNameList:"Grant" type:"list"`

	Owner *Owner `type:"structure"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataGetObjectACLOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetObjectACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Return the object only if its entity tag (ETag) is the same as the one specified,
	// otherwise return a 412 (precondition failed).
	IfMatch *string `location:"header" locationName:"If-Match" type:"string"`

	// Return the object only if it has been modified since the specified time,
	// otherwise return a 304 (not modified).
	IfModifiedSince *time.Time `location:"header" locationName:"If-Modified-Since" type:"timestamp" timestampFormat:"rfc822"`

	// Return the object only if its entity tag (ETag) is different from the one
	// specified, otherwise return a 304 (not modified).
	IfNoneMatch *string `location:"header" locationName:"If-None-Match" type:"string"`

	// Return the object only if it has not been modified since the specified time,
	// otherwise return a 412 (precondition failed).
	IfUnmodifiedSince *time.Time `location:"header" locationName:"If-Unmodified-Since" type:"timestamp" timestampFormat:"rfc822"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Downloads the specified range bytes of an object. For more information about
	// the HTTP Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
	Range *string `location:"header" locationName:"Range" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Sets the Cache-Control header of the response.
	ResponseCacheControl *string `location:"querystring" locationName:"response-cache-control" type:"string"`

	// Sets the Content-Disposition header of the response
	ResponseContentDisposition *string `location:"querystring" locationName:"response-content-disposition" type:"string"`

	// Sets the Content-Encoding header of the response.
	ResponseContentEncoding *string `location:"querystring" locationName:"response-content-encoding" type:"string"`

	// Sets the Content-Language header of the response.
	ResponseContentLanguage *string `location:"querystring" locationName:"response-content-language" type:"string"`

	// Sets the Content-Type header of the response.
	ResponseContentType *string `location:"querystring" locationName:"response-content-type" type:"string"`

	// Sets the Expires header of the response.
	ResponseExpires *time.Time `location:"querystring" locationName:"response-expires" type:"timestamp" timestampFormat:"iso8601"`

	// Specify the encoding type of the client.
	// If you want to compress and transmit the returned content using gzip,
	// you need to add a request header: Accept-Encoding:gzip。
	// KS3 will determine whether to return gzip compressed data based on the
	// Content-Type and Object size (not less than 1 KB) of the object.
	// Value: gzip、br、deflate
	AcceptEncoding *string `location:"header" locationName:"Accept-Encoding" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	TrafficLimit *int64 `location:"header" locationName:"x-kss-traffic-limit" type:"string"`

	// Progress callback function
	ProgressFn aws.ProgressFunc `location:"function"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetObjectInput `json:"-" xml:"-"`
}

type metadataGetObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectOutput struct {
	AcceptRanges *string `location:"header" locationName:"accept-ranges" type:"string"`

	// Object data.
	Body io.ReadCloser `type:"blob"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// The portion of the object returned in the response.
	ContentRange *string `location:"header" locationName:"Content-Range" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Specifies whether the object retrieved was (true) or was not (false) a Delete
	// Marker. If false, this response header does not appear in the response.
	DeleteMarker *bool `location:"header" locationName:"x-amz-delete-marker" type:"boolean"`

	// An ETag is an opaque identifier assigned by a web server to a specific version
	// of a resource found at a URL
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If the object expiration is configured (see PUT Bucket lifecycle), the response
	// includes this header. It includes the expiry-date and rule-id key value pairs
	// providing object expiration information. The value of the rule-id is URL
	// encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Last modified date of the object
	LastModified *time.Time `location:"header" locationName:"Last-Modified" type:"timestamp" timestampFormat:"rfc822"`

	// This is set to the number of metadata entries not returned in x-amz-meta
	// headers. This can happen if you create metadata using an API like SOAP that
	// supports more flexible metadata than the REST API. For example, using SOAP,
	// you can create metadata whose values are not legal HTTP headers.
	MissingMeta *int64 `location:"header" locationName:"x-amz-missing-meta" type:"integer"`

	ReplicationStatus *string `location:"header" locationName:"x-amz-replication-status" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// Provides information about object restoration operation and expiration time
	// of the restored object copy.
	Restore *string `location:"header" locationName:"x-amz-restore" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	metadataGetObjectOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetObjectOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type GetObjectTorrentInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetObjectTorrentInput `json:"-" xml:"-"`
}

type metadataGetObjectTorrentInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectTorrentOutput struct {
	Body io.ReadCloser `type:"blob"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataGetObjectTorrentOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetObjectTorrentOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type Grant struct {
	Grantee *Grantee `type:"structure"`

	// Specifies the permission given to the grantee.
	Permission *string `type:"string"`

	metadataGrant `json:"-" xml:"-"`
}

type metadataGrant struct {
	SDKShapeTraits bool `type:"structure"`
}

type Grantee struct {
	// Screen name of the grantee.
	DisplayName *string `type:"string"`

	// Email address of the grantee.
	EmailAddress *string `type:"string"`

	// The canonical user ID of the grantee.
	ID *string `type:"string"`

	// Type of grantee
	Type *string `locationName:"xsi:type" type:"string" xmlAttribute:"true" required:"true"`

	// URI of the grantee group.
	URI *string `type:"string"`

	metadataGrantee `json:"-" xml:"-"`
}

type metadataGrantee struct {
	SDKShapeTraits bool `type:"structure" xmlPrefix:"xsi" xmlURI:"http://www.w3.org/2001/XMLSchema-instance"`
}

type HeadBucketInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataHeadBucketInput `json:"-" xml:"-"`
}

type metadataHeadBucketInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type HeadBucketOutput struct {
	metadataHeadBucketOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataHeadBucketOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type HeadObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Return the object only if its entity tag (ETag) is the same as the one specified,
	// otherwise return a 412 (precondition failed).
	IfMatch *string `location:"header" locationName:"If-Match" type:"string"`

	// Return the object only if it has been modified since the specified time,
	// otherwise return a 304 (not modified).
	IfModifiedSince *time.Time `location:"header" locationName:"If-Modified-Since" type:"timestamp" timestampFormat:"rfc822"`

	// Return the object only if its entity tag (ETag) is different from the one
	// specified, otherwise return a 304 (not modified).
	IfNoneMatch *string `location:"header" locationName:"If-None-Match" type:"string"`

	// Return the object only if it has not been modified since the specified time,
	// otherwise return a 412 (precondition failed).
	IfUnmodifiedSince *time.Time `location:"header" locationName:"If-Unmodified-Since" type:"timestamp" timestampFormat:"rfc822"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Downloads the specified range bytes of an object. For more information about
	// the HTTP Range header, go to http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.
	Range *string `location:"header" locationName:"Range" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// VersionId used to reference a specific version of the object.
	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataHeadObjectInput `json:"-" xml:"-"`
}

type metadataHeadObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type HeadObjectOutput struct {
	AcceptRanges *string `location:"header" locationName:"accept-ranges" type:"string"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Specifies whether the object retrieved was (true) or was not (false) a Delete
	// Marker. If false, this response header does not appear in the response.
	DeleteMarker *bool `location:"header" locationName:"x-amz-delete-marker" type:"boolean"`

	// An ETag is an opaque identifier assigned by a web server to a specific version
	// of a resource found at a URL
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If the object expiration is configured (see PUT Bucket lifecycle), the response
	// includes this header. It includes the expiry-date and rule-id key value pairs
	// providing object expiration information. The value of the rule-id is URL
	// encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Last modified date of the object
	LastModified *time.Time `location:"header" locationName:"Last-Modified" type:"timestamp" timestampFormat:"rfc822"`

	// This is set to the number of metadata entries not returned in x-amz-meta
	// headers. This can happen if you create metadata using an API like SOAP that
	// supports more flexible metadata than the REST API. For example, using SOAP,
	// you can create metadata whose values are not legal HTTP headers.
	MissingMeta *int64 `location:"header" locationName:"x-amz-missing-meta" type:"integer"`

	ReplicationStatus *string `location:"header" locationName:"x-amz-replication-status" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// Provides information about object restoration operation and expiration time
	// of the restored object copy.
	Restore *string `location:"header" locationName:"x-amz-restore" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	metadataHeadObjectOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataHeadObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type IndexDocument struct {
	// A suffix that is appended to a request that is for a directory on the website
	// endpoint (e.g. if the suffix is index.html and you make a request to samplebucket/images/
	// the data that is returned will be for the object with the key name images/index.html)
	// The suffix must not be empty and must not include a slash character.
	Suffix *string `type:"string" required:"true"`

	metadataIndexDocument `json:"-" xml:"-"`
}

type metadataIndexDocument struct {
	SDKShapeTraits bool `type:"structure"`
}

type Initiator struct {
	// Name of the Principal.
	DisplayName *string `type:"string"`

	// If the principal is an AWS account, it provides the Canonical User ID. If
	// the principal is an IAM User, it provides a user ARN value.
	ID *string `type:"string"`

	metadataInitiator `json:"-" xml:"-"`
}

type metadataInitiator struct {
	SDKShapeTraits bool `type:"structure"`
}

// LambdaFunctionConfiguration Container for specifying the AWS Lambda notification configuration.
type LambdaFunctionConfiguration struct {
	Events []*string `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Lambda cloud function ARN that Amazon S3 can invoke when it detects events
	// of the specified type.
	LambdaFunctionARN *string `locationName:"CloudFunction" type:"string" required:"true"`

	metadataLambdaFunctionConfiguration `json:"-" xml:"-"`
}

type metadataLambdaFunctionConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListBucketsInput struct {
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataListBucketsInput `json:"-" xml:"-"`
}

type metadataListBucketsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListBucketsOutput struct {
	Buckets []*Bucket `locationNameList:"Bucket" type:"list"`

	Owner *Owner `type:"structure"`

	metadataListBucketsOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataListBucketsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListMultipartUploadsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Character you use to group keys.
	Delimiter *string `location:"querystring" locationName:"delimiter" type:"string"`

	// Requests Amazon S3 to encode the object keys in the response and specifies
	// the encoding method to use. An object key may contain any Unicode character;
	// however, XML 1.0 parser cannot parse some characters, such as characters
	// with an ASCII value from 0 to 10. For characters that are not supported in
	// XML 1.0, you can add this parameter to request that Amazon S3 encode the
	// keys in the response.
	EncodingType *string `location:"querystring" locationName:"encoding-type" type:"string"`

	// Together with upload-id-marker, this parameter specifies the multipart upload
	// after which listing should begin.
	KeyMarker *string `location:"querystring" locationName:"key-marker" type:"string"`

	// Sets the maximum number of multipart uploads, from 1 to 1,000, to return
	// in the response body. 1,000 is the maximum number of uploads that can be
	// returned in a response.
	MaxUploads *int64 `location:"querystring" locationName:"max-uploads" type:"integer"`

	// Lists in-progress uploads only for those keys that begin with the specified
	// prefix.
	Prefix *string `location:"querystring" locationName:"prefix" type:"string"`

	// Together with key-marker, specifies the multipart upload after which listing
	// should begin. If key-marker is not specified, the upload-id-marker parameter
	// is ignored.
	UploadIDMarker *string `location:"querystring" locationName:"upload-id-marker" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataListMultipartUploadsInput `json:"-" xml:"-"`
}

type metadataListMultipartUploadsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListMultipartUploadsOutput struct {
	// Name of the bucket to which the multipart upload was initiated.
	Bucket *string `type:"string"`

	CommonPrefixes []*CommonPrefix `type:"list" flattened:"true"`

	Delimiter *string `type:"string"`

	// Encoding type used by Amazon S3 to encode object keys in the response.
	EncodingType *string `type:"string"`

	// Indicates whether the returned list of multipart uploads is truncated. A
	// value of true indicates that the list was truncated. The list can be truncated
	// if the number of multipart uploads exceeds the limit allowed or specified
	// by max uploads.
	IsTruncated *bool `type:"boolean"`

	// The key at or after which the listing began.
	KeyMarker *string `type:"string"`

	// Maximum number of multipart uploads that could have been included in the
	// response.
	MaxUploads *int64 `type:"integer"`

	// When a list is truncated, this element specifies the value that should be
	// used for the key-marker request parameter in a subsequent request.
	NextKeyMarker *string `type:"string"`

	// When a list is truncated, this element specifies the value that should be
	// used for the upload-id-marker request parameter in a subsequent request.
	NextUploadIDMarker *string `locationName:"NextUploadIdMarker" type:"string"`

	// When a prefix is provided in the request, this field contains the specified
	// prefix. The result contains only keys starting with the specified prefix.
	Prefix *string `type:"string"`

	// Upload ID after which listing began.
	UploadIDMarker *string `locationName:"UploadIdMarker" type:"string"`

	Uploads []*MultipartUpload `locationName:"Upload" type:"list" flattened:"true"`

	metadataListMultipartUploadsOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataListMultipartUploadsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectVersionsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// A delimiter is a character you use to group keys.
	Delimiter *string `location:"querystring" locationName:"delimiter" type:"string"`

	// Requests Amazon S3 to encode the object keys in the response and specifies
	// the encoding method to use. An object key may contain any Unicode character;
	// however, XML 1.0 parser cannot parse some characters, such as characters
	// with an ASCII value from 0 to 10. For characters that are not supported in
	// XML 1.0, you can add this parameter to request that Amazon S3 encode the
	// keys in the response.
	EncodingType *string `location:"querystring" locationName:"encoding-type" type:"string"`

	// Specifies the key to start with when listing objects in a bucket.
	KeyMarker *string `location:"querystring" locationName:"key-marker" type:"string"`

	// Sets the maximum number of keys returned in the response. The response might
	// contain fewer keys but will never contain more.
	MaxKeys *int64 `location:"querystring" locationName:"max-keys" type:"integer"`

	// Limits the response to keys that begin with the specified prefix.
	Prefix *string `location:"querystring" locationName:"prefix" type:"string"`

	// Specifies the object version you want to start listing from.
	VersionIDMarker *string `location:"querystring" locationName:"version-id-marker" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataListObjectVersionsInput `json:"-" xml:"-"`
}

type metadataListObjectVersionsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectVersionsOutput struct {
	CommonPrefixes []*CommonPrefix `type:"list" flattened:"true"`

	DeleteMarkers []*DeleteMarkerEntry `locationName:"DeleteMarker" type:"list" flattened:"true"`

	Delimiter *string `type:"string"`

	// Encoding type used by Amazon S3 to encode object keys in the response.
	EncodingType *string `type:"string"`

	// A flag that indicates whether or not Amazon S3 returned all of the results
	// that satisfied the search criteria. If your results were truncated, you can
	// make a follow-up paginated request using the NextKeyMarker and NextVersionIdMarker
	// response parameters as a starting place in another request to return the
	// rest of the results.
	IsTruncated *bool `type:"boolean"`

	// Marks the last Key returned in a truncated response.
	KeyMarker *string `type:"string"`

	MaxKeys *int64 `type:"integer"`

	Name *string `type:"string"`

	// Use this value for the key marker request parameter in a subsequent request.
	NextKeyMarker *string `type:"string"`

	// Use this value for the next version id marker parameter in a subsequent request.
	NextVersionIDMarker *string `locationName:"NextVersionIdMarker" type:"string"`

	Prefix *string `type:"string"`

	VersionIDMarker *string `locationName:"VersionIdMarker" type:"string"`

	Versions []*ObjectVersion `locationName:"Version" type:"list" flattened:"true"`

	metadataListObjectVersionsOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataListObjectVersionsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// A delimiter is a character you use to group keys.
	Delimiter *string `location:"querystring" locationName:"delimiter" type:"string"`

	// Requests Amazon S3 to encode the object keys in the response and specifies
	// the encoding method to use. An object key may contain any Unicode character;
	// however, XML 1.0 parser cannot parse some characters, such as characters
	// with an ASCII value from 0 to 10. For characters that are not supported in
	// XML 1.0, you can add this parameter to request that Amazon S3 encode the
	// keys in the response.
	EncodingType *string `location:"querystring" locationName:"encoding-type" type:"string"`

	// Specifies the key to start with when listing objects in a bucket.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// Sets the maximum number of keys returned in the response. The response might
	// contain fewer keys but will never contain more.
	MaxKeys *int64 `location:"querystring" locationName:"max-keys" type:"integer"`

	// Limits the response to keys that begin with the specified prefix.
	Prefix *string `location:"querystring" locationName:"prefix" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataListObjectsInput `json:"-" xml:"-"`
}

type metadataListObjectsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListObjectsOutput struct {
	CommonPrefixes []*CommonPrefix `type:"list" flattened:"true"`

	Contents []*Object `type:"list" flattened:"true"`

	Delimiter *string `type:"string"`

	// Encoding type used by Amazon S3 to encode object keys in the response.
	EncodingType *string `type:"string"`

	// A flag that indicates whether or not Amazon S3 returned all of the results
	// that satisfied the search criteria.
	IsTruncated *bool `type:"boolean"`

	Marker *string `type:"string"`

	MaxKeys *int64 `type:"integer"`

	Name *string `type:"string"`

	// When response is truncated (the IsTruncated element value in the response
	// is true), you can use the key name in this field as marker in the subsequent
	// request to get next set of objects. Amazon S3 lists objects in alphabetical
	// order Note: This element is returned only if you have delimiter request parameter
	// specified. If response does not include the NextMaker and it is truncated,
	// you can use the value of the last Key in the response as the marker in the
	// subsequent request to get the next set of object keys.
	NextMarker *string `type:"string"`

	Prefix *string `type:"string"`

	metadataListObjectsOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataListObjectsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListPartsInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Sets the maximum number of parts to return.
	MaxParts *int64 `location:"querystring" locationName:"max-parts" type:"integer"`

	// Specifies the part after which listing should begin. Only parts with higher
	// part numbers will be listed.
	PartNumberMarker *int64 `location:"querystring" locationName:"part-number-marker" type:"integer"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Upload ID identifying the multipart upload whose parts are being listed.
	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataListPartsInput `json:"-" xml:"-"`
}

type metadataListPartsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type ListPartsOutput struct {
	// Name of the bucket to which the multipart upload was initiated.
	Bucket *string `type:"string"`

	// Identifies who initiated the multipart upload.
	Initiator *Initiator `type:"structure"`

	// Indicates whether the returned list of parts is truncated.
	IsTruncated *bool `type:"boolean"`

	// Object key for which the multipart upload was initiated.
	Key *string `type:"string"`

	// Maximum number of parts that were allowed in the response.
	MaxParts *int64 `type:"integer"`

	// When a list is truncated, this element specifies the last part in the list,
	// as well as the value to use for the part-number-marker request parameter
	// in a subsequent request.
	NextPartNumberMarker *int64 `type:"integer"`

	Owner *Owner `type:"structure"`

	// Part number after which listing begins.
	PartNumberMarker *int64 `type:"integer"`

	Parts []*Part `locationName:"Part" type:"list" flattened:"true"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// Upload ID identifying the multipart upload whose parts are being listed.
	UploadID *string `locationName:"UploadId" type:"string"`

	metadataListPartsOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataListPartsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type LoggingEnabled struct {
	// Specifies the bucket where you want Amazon S3 to store server access logs.
	// You can have your logs delivered to any bucket that you own, including the
	// same bucket that is being logged. You can also configure multiple buckets
	// to deliver their logs to the same target bucket. In this case you should
	// choose a different TargetPrefix for each source bucket so that the delivered
	// log files can be distinguished by key.
	TargetBucket *string `type:"string"`

	TargetGrants []*TargetGrant `locationNameList:"Grant" type:"list"`

	// This element lets you specify a prefix for the keys that the log files will
	// be stored under.
	TargetPrefix *string `type:"string"`

	metadataLoggingEnabled `json:"-" xml:"-"`
}

type metadataLoggingEnabled struct {
	SDKShapeTraits bool `type:"structure"`
}

type MultipartUpload struct {
	// Date and time at which the multipart upload was initiated.
	Initiated *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Identifies who initiated the multipart upload.
	Initiator *Initiator `type:"structure"`

	// Key of the object for which the multipart upload was initiated.
	Key *string `type:"string"`

	Owner *Owner `type:"structure"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// Upload ID that identifies the multipart upload.
	UploadID *string `locationName:"UploadId" type:"string"`

	metadataMultipartUpload `json:"-" xml:"-"`
}

type metadataMultipartUpload struct {
	SDKShapeTraits bool `type:"structure"`
}

// NotificationConfiguration Container for specifying the notification configuration of the bucket. If
// this element is empty, notifications are turned off on the bucket.
type NotificationConfiguration struct {
	LambdaFunctionConfigurations []*LambdaFunctionConfiguration `locationName:"CloudFunctionConfiguration" type:"list" flattened:"true"`

	QueueConfigurations []*QueueConfiguration `locationName:"QueueConfiguration" type:"list" flattened:"true"`

	TopicConfigurations []*TopicConfiguration `locationName:"TopicConfiguration" type:"list" flattened:"true"`

	metadataNotificationConfiguration `json:"-" xml:"-"`
}

type metadataNotificationConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type NotificationConfigurationDeprecated struct {
	CloudFunctionConfiguration *CloudFunctionConfiguration `type:"structure"`

	QueueConfiguration *QueueConfigurationDeprecated `type:"structure"`

	TopicConfiguration *TopicConfigurationDeprecated `type:"structure"`

	metadataNotificationConfigurationDeprecated `json:"-" xml:"-"`
}

type metadataNotificationConfigurationDeprecated struct {
	SDKShapeTraits bool `type:"structure"`
}

type Object struct {
	ETag *string `type:"string"`

	Key *string `type:"string"`

	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	Owner *Owner `type:"structure"`

	Size *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// The redundancy type of the object.
	Redundancy *string `type:"string"`

	metadataObject `json:"-" xml:"-"`
}

type metadataObject struct {
	SDKShapeTraits bool `type:"structure"`
}

type ObjectIdentifier struct {
	// Key name of the object to delete.
	Key *string `type:"string" required:"true"`

	// VersionId for the specific version of the object to delete.
	VersionID *string `locationName:"VersionId" type:"string"`

	metadataObjectIdentifier `json:"-" xml:"-"`
}

type metadataObjectIdentifier struct {
	SDKShapeTraits bool `type:"structure"`
}

type ObjectVersion struct {
	ETag *string `type:"string"`

	// Specifies whether the object is (true) or is not (false) the latest version
	// of an object.
	IsLatest *bool `type:"boolean"`

	// The object key.
	Key *string `type:"string"`

	// Date and time the object was last modified.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	Owner *Owner `type:"structure"`

	// Size in bytes of the object.
	Size *int64 `type:"integer"`

	// The class of storage used to store the object.
	StorageClass *string `type:"string"`

	// Version ID of an object.
	VersionID *string `locationName:"VersionId" type:"string"`

	metadataObjectVersion `json:"-" xml:"-"`
}

type metadataObjectVersion struct {
	SDKShapeTraits bool `type:"structure"`
}

type Owner struct {
	DisplayName *string `type:"string"`

	ID *string `type:"string"`

	metadataOwner `json:"-" xml:"-"`
}

type metadataOwner struct {
	SDKShapeTraits bool `type:"structure"`
}

type Part struct {
	// Entity tag returned when the part was uploaded.
	ETag *string `type:"string"`

	// Date and time at which the part was uploaded.
	LastModified *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Part number identifying the part.
	PartNumber *int64 `type:"integer"`

	// Size of the uploaded part data.
	Size *int64 `type:"integer"`

	metadataPart `json:"-" xml:"-"`
}

type metadataPart struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketACLInput struct {
	// The canned ACL to apply to the bucket.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	AccessControlPolicy *AccessControlPolicy `locationName:"AccessControlPolicy" type:"structure"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Allows grantee the read, write, read ACP, and write ACP permissions on the
	// bucket.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to list the objects in the bucket.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the bucket ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to create, overwrite, and delete any object in the bucket.
	GrantWrite *string `location:"header" locationName:"x-amz-grant-write" type:"string"`

	// Allows grantee to write the ACL for the applicable bucket.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketACLInput `json:"-" xml:"-"`
}

type metadataPutBucketACLInput struct {
	SDKShapeTraits bool `type:"structure" payload:"AccessControlPolicy"`
}

type PutBucketACLOutput struct {
	metadataPutBucketACLOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketLoggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	BucketLoggingStatus *BucketLoggingStatus `locationName:"BucketLoggingStatus" type:"structure" required:"true" xmlURI:"http://s3.amazonaws.com/doc/2006-03-01/"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketLoggingInput `json:"-" xml:"-"`
}

type metadataPutBucketLoggingInput struct {
	SDKShapeTraits bool `type:"structure" payload:"BucketLoggingStatus"`
}

type PutBucketLoggingOutput struct {
	metadataPutBucketLoggingOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketLoggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketNotificationConfigurationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Container for specifying the notification configuration of the bucket. If
	// this element is empty, notifications are turned off on the bucket.
	NotificationConfiguration *NotificationConfiguration `locationName:"NotificationConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketNotificationConfigurationInput `json:"-" xml:"-"`
}

type metadataPutBucketNotificationConfigurationInput struct {
	SDKShapeTraits bool `type:"structure" payload:"NotificationConfiguration"`
}

type PutBucketNotificationConfigurationOutput struct {
	metadataPutBucketNotificationConfigurationOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketNotificationConfigurationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketNotificationInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	NotificationConfiguration *NotificationConfigurationDeprecated `locationName:"NotificationConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketNotificationInput `json:"-" xml:"-"`
}

type metadataPutBucketNotificationInput struct {
	SDKShapeTraits bool `type:"structure" payload:"NotificationConfiguration"`
}

type PutBucketNotificationOutput struct {
	metadataPutBucketNotificationOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketNotificationOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketPolicyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// The bucket policy as a JSON document.
	Policy *string `type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketPolicyInput `json:"-" xml:"-"`
}

type metadataPutBucketPolicyInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Policy"`
}

type PutBucketPolicyOutput struct {
	metadataPutBucketPolicyOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketRequestPaymentInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	RequestPaymentConfiguration *RequestPaymentConfiguration `locationName:"RequestPaymentConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketRequestPaymentInput `json:"-" xml:"-"`
}

type metadataPutBucketRequestPaymentInput struct {
	SDKShapeTraits bool `type:"structure" payload:"RequestPaymentConfiguration"`
}

type PutBucketRequestPaymentOutput struct {
	metadataPutBucketRequestPaymentOutput `json:"-" xml:"-"`
}

type metadataPutBucketRequestPaymentOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketVersioningInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// The concatenation of the authentication device's serial number, a space,
	// and the value that is displayed on your authentication device.
	MFA *string `location:"header" locationName:"x-amz-mfa" type:"string"`

	VersioningConfiguration *VersioningConfiguration `locationName:"VersioningConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketVersioningInput `json:"-" xml:"-"`
}

type metadataPutBucketVersioningInput struct {
	SDKShapeTraits bool `type:"structure" payload:"VersioningConfiguration"`
}

type PutBucketVersioningOutput struct {
	metadataPutBucketVersioningOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketVersioningOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutBucketWebsiteInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	WebsiteConfiguration *WebsiteConfiguration `locationName:"WebsiteConfiguration" type:"structure" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutBucketWebsiteInput `json:"-" xml:"-"`
}

type metadataPutBucketWebsiteInput struct {
	SDKShapeTraits bool `type:"structure" payload:"WebsiteConfiguration"`
}

type PutBucketWebsiteOutput struct {
	metadataPutBucketWebsiteOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutBucketWebsiteOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutObjectACLInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	AccessControlPolicy *AccessControlPolicy `locationName:"AccessControlPolicy" type:"structure"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Allows grantee the read, write, read ACP, and write ACP permissions on the
	// bucket.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to list the objects in the bucket.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the bucket ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to create, overwrite, and delete any object in the bucket.
	GrantWrite *string `location:"header" locationName:"x-amz-grant-write" type:"string"`

	// Allows grantee to write the ACL for the applicable bucket.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutObjectACLInput `json:"-" xml:"-"`
}

type metadataPutObjectACLInput struct {
	SDKShapeTraits bool `type:"structure" payload:"AccessControlPolicy"`
}

type PutObjectACLOutput struct {
	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	metadataPutObjectACLOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutObjectACLOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutObjectInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	// Object data.
	Body io.ReadSeeker `type:"blob"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes. This parameter is useful when the size of the
	// body cannot be determined automatically.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Specifies the object tag of the object. Multiple tags can be set at the same time, such as: TagA=A&TagB=B.
	// Note: Key and Value need to be URL-encoded first. If an item does not have "=", the Value is considered to be an empty string.
	Tagging *string `location:"header" locationName:"x-amz-tagging" type:"string"`

	// Specifies whether the object is forbidden to overwrite.
	ForbidOverwrite *bool `location:"header" locationName:"x-amz-forbid-overwrite" type:"boolean"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	ContentMaxLength *int64 `location:"header" locationName:"x-amz-content-maxlength" type:"integer"`

	CallbackUrl *string `location:"header" locationName:"x-kss-callbackurl" type:"string"`

	CallbackBody *string `location:"header" locationName:"x-kss-callbackbody" type:"string"`

	TrafficLimit *int64 `location:"header" locationName:"x-kss-traffic-limit" type:"integer"`

	ContentMD5 *string `location:"header" locationName:"Content-MD5" type:"string"`

	// Progress callback function
	ProgressFn aws.ProgressFunc `location:"function"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutObjectInput `json:"-" xml:"-"`
}

type PutReaderInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-amz-acl" type:"string"`

	// Object data.
	Body io.Reader `type:"blob"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// Size of the body in bytes. This parameter is useful when the size of the
	// body cannot be determined automatically.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Specifies the object tag of the object. Multiple tags can be set at the same time, such as: TagA=A&TagB=B.
	// Note: Key and Value need to be URL-encoded first. If an item does not have "=", the Value is considered to be an empty string.
	Tagging *string `location:"header" locationName:"x-amz-tagging" type:"string"`

	// Specifies whether the object is forbidden to overwrite.
	ForbidOverwrite *bool `location:"header" locationName:"x-amz-forbid-overwrite" type:"boolean"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	ContentMaxLength *int64 `location:"header" locationName:"x-amz-content-maxlength" type:"integer"`

	CallbackUrl *string `location:"header" locationName:"x-kss-callbackurl" type:"string"`

	CallbackBody *string `location:"header" locationName:"x-kss-callbackbody" type:"string"`

	TrafficLimit *int64 `location:"header" locationName:"x-kss-traffic-limit" type:"integer"`

	ContentMD5 *string `location:"header" locationName:"Content-MD5" type:"string"`

	// Progress callback function
	ProgressFn aws.ProgressFunc `location:"function"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutObjectInput `json:"-" xml:"-"`
}

type metadataPutObjectInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type PutObjectOutput struct {
	// Entity tag for the uploaded object.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// If the object expiration is configured, this will contain the expiration
	// date (expiry-date) and rule ID (rule-id). The value of rule-id is URL encoded.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// Version of the object.
	VersionID *string `location:"header" locationName:"x-amz-version-id" type:"string"`

	NewFileName *string `location:"header" locationName:"newfilename" type:"string"`

	metadataPutObjectOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// QueueConfiguration Container for specifying an configuration when you want Amazon S3 to publish
// events to an Amazon Simple Queue Service (Amazon SQS) queue.
type QueueConfiguration struct {
	Events []*string `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Amazon SQS queue ARN to which Amazon S3 will publish a message when it detects
	// events of specified type.
	QueueARN *string `locationName:"Queue" type:"string" required:"true"`

	metadataQueueConfiguration `json:"-" xml:"-"`
}

type metadataQueueConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type QueueConfigurationDeprecated struct {
	// Bucket event for which to send notifications.
	Event *string `type:"string"`

	Events []*string `locationName:"Event" type:"list" flattened:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	Queue *string `type:"string"`

	metadataQueueConfigurationDeprecated `json:"-" xml:"-"`
}

type metadataQueueConfigurationDeprecated struct {
	SDKShapeTraits bool `type:"structure"`
}

type Redirect struct {
	// The HTTP redirect code to use on the response. Not required if one of the
	// siblings is present.
	HTTPRedirectCode *string `locationName:"HttpRedirectCode" type:"string"`

	// The host name to use in the redirect request.
	HostName *string `type:"string"`

	// Protocol to use (http, https) when redirecting requests. The default is the
	// protocol that is used in the original request.
	Protocol *string `type:"string"`

	// The object key prefix to use in the redirect request. For example, to redirect
	// requests for all pages with prefix docs/ (objects in the docs/ folder) to
	// documents/, you can set a condition block with KeyPrefixEquals set to docs/
	// and in the Redirect set ReplaceKeyPrefixWith to /documents. Not required
	// if one of the siblings is present. Can be present only if ReplaceKeyWith
	// is not provided.
	ReplaceKeyPrefixWith *string `type:"string"`

	// The specific object key to use in the redirect request. For example, redirect
	// request to error.html. Not required if one of the sibling is present. Can
	// be present only if ReplaceKeyPrefixWith is not provided.
	ReplaceKeyWith *string `type:"string"`

	metadataRedirect `json:"-" xml:"-"`
}

type metadataRedirect struct {
	SDKShapeTraits bool `type:"structure"`
}

type RedirectAllRequestsTo struct {
	// Name of the host where requests will be redirected.
	HostName *string `type:"string" required:"true"`

	// Protocol to use (http, https) when redirecting requests. The default is the
	// protocol that is used in the original request.
	Protocol *string `type:"string"`

	metadataRedirectAllRequestsTo `json:"-" xml:"-"`
}

type metadataRedirectAllRequestsTo struct {
	SDKShapeTraits bool `type:"structure"`
}

type RequestPaymentConfiguration struct {
	// Specifies who pays for the download and request fees.
	Payer *string `type:"string" required:"true"`

	metadataRequestPaymentConfiguration `json:"-" xml:"-"`
}

type metadataRequestPaymentConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type RestoreObjectInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	RestoreRequest *RestoreRequest `locationName:"RestoreRequest" type:"structure"`

	VersionID *string `location:"querystring" locationName:"versionId" type:"string"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataRestoreObjectInput `json:"-" xml:"-"`
}

type metadataRestoreObjectInput struct {
	SDKShapeTraits bool `type:"structure" payload:"RestoreRequest"`
}

type RestoreObjectOutput struct {
	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type RestoreRequest struct {
	// Lifetime of the active copy in days
	Days *int64 `type:"integer" required:"true"`

	metadataRestoreRequest `json:"-" xml:"-"`
}

type metadataRestoreRequest struct {
	SDKShapeTraits bool `type:"structure"`
}

type RoutingRule struct {
	// A container for describing a condition that must be met for the specified
	// redirect to apply. For example, 1. If request is for pages in the /docs folder,
	// redirect to the /documents folder. 2. If request results in HTTP error 4xx,
	// redirect request to another host where you might process the error.
	Condition *Condition `type:"structure"`

	// Container for redirect information. You can redirect requests to another
	// host, to another page, or with another protocol. In the event of an error,
	// you can can specify a different error code to return.
	Redirect *Redirect `type:"structure" required:"true"`

	metadataRoutingRule `json:"-" xml:"-"`
}

type metadataRoutingRule struct {
	SDKShapeTraits bool `type:"structure"`
}

type Tag struct {
	// Name of the tag.
	Key *string `type:"string" required:"true"`

	// Value of the tag.
	Value *string `type:"string" required:"true"`

	metadataTag `json:"-" xml:"-"`
}

type metadataTag struct {
	SDKShapeTraits bool `type:"structure"`
}

type Tagging struct {
	TagSet []*Tag `locationNameList:"Tag" type:"list" required:"true"`

	metadataTagging `json:"-" xml:"-"`
}

func (t *Tagging) ToString() string {
	if t == nil || t.TagSet == nil || len(t.TagSet) == 0 {
		return ""
	}

	var builder strings.Builder
	for i := 0; i < len(t.TagSet); i++ {
		if i > 0 {
			builder.WriteString("&")
		}
		tag := t.TagSet[i]
		encodedKey := url.QueryEscape(aws.ToString(tag.Key))
		encodedValue := url.QueryEscape(aws.ToString(tag.Value))
		builder.WriteString(encodedKey)
		builder.WriteString("=")
		builder.WriteString(encodedValue)
	}

	return builder.String()
}

type metadataTagging struct {
	SDKShapeTraits bool `type:"structure"`
}

type TargetGrant struct {
	Grantee *Grantee `type:"structure"`

	// Logging permissions assigned to the Grantee for the bucket.
	Permission *string `type:"string"`

	metadataTargetGrant `json:"-" xml:"-"`
}

type metadataTargetGrant struct {
	SDKShapeTraits bool `type:"structure"`
}

// TopicConfiguration Container for specifying the configuration when you want Amazon S3 to publish
// events to an Amazon Simple Notification Service (Amazon SNS) topic.
type TopicConfiguration struct {
	Events []*string `locationName:"Event" type:"list" flattened:"true" required:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Amazon SNS topic ARN to which Amazon S3 will publish a message when it detects
	// events of specified type.
	TopicARN *string `locationName:"Topic" type:"string" required:"true"`

	metadataTopicConfiguration `json:"-" xml:"-"`
}

type metadataTopicConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type TopicConfigurationDeprecated struct {
	// Bucket event for which to send notifications.
	Event *string `type:"string"`

	Events []*string `locationName:"Event" type:"list" flattened:"true"`

	// Optional unique identifier for configurations in a notification configuration.
	// If you don't provide one, Amazon S3 will assign an ID.
	ID *string `locationName:"Id" type:"string"`

	// Amazon SNS topic to which Amazon S3 will publish a message to report the
	// specified events for the bucket.
	Topic *string `type:"string"`

	metadataTopicConfigurationDeprecated `json:"-" xml:"-"`
}

type metadataTopicConfigurationDeprecated struct {
	SDKShapeTraits bool `type:"structure"`
}

type UploadPartCopyInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	SourceBucket *string `location:"uri" locationName:"sourceBucket" type:"string"`

	SourceKey *string `location:"uri" locationName:"sourceKey" type:"string"`

	// The name of the source bucket and key name of the source object, separated
	// by a slash (/). Must be URL-encoded.
	CopySource *string `location:"header" locationName:"x-amz-copy-source" type:"string" required:"true"`

	// Copies the object if its entity tag (ETag) matches the specified tag.
	CopySourceIfMatch *string `location:"header" locationName:"x-amz-copy-source-if-match" type:"string"`

	// Copies the object if it has been modified since the specified time.
	CopySourceIfModifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-modified-since" type:"timestamp" timestampFormat:"rfc822"`

	// Copies the object if its entity tag (ETag) is different than the specified
	// ETag.
	CopySourceIfNoneMatch *string `location:"header" locationName:"x-amz-copy-source-if-none-match" type:"string"`

	// Copies the object if it hasn't been modified since the specified time.
	CopySourceIfUnmodifiedSince *time.Time `location:"header" locationName:"x-amz-copy-source-if-unmodified-since" type:"timestamp" timestampFormat:"rfc822"`

	// The range of bytes to copy from the source object. The range value must use
	// the form bytes=first-last, where the first and last are the zero-based byte
	// offsets to copy. For example, bytes=0-9 indicates that you want to copy the
	// first ten bytes of the source. You can copy a range only if the source object
	// is greater than 5 GB.
	CopySourceRange *string `location:"header" locationName:"x-amz-copy-source-range" type:"string"`

	// Specifies the algorithm to use when decrypting the source object (e.g., AES256).
	CopySourceSSECustomerAlgorithm *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use to decrypt
	// the source object. The encryption key provided in this header must be one
	// that was used when the source object was created.
	CopySourceSSECustomerKey *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	CopySourceSSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-copy-source-server-side-encryption-customer-key-MD5" type:"string"`

	// Part number of part being copied.
	PartNumber *int64 `location:"querystring" locationName:"partNumber" type:"integer" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header. This must be the same encryption key specified in the initiate multipart
	// upload request.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Upload ID identifying the multipart upload whose part is being copied.
	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataUploadPartCopyInput `json:"-" xml:"-"`
}

type metadataUploadPartCopyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type UploadPartCopyOutput struct {
	CopyPartResult *CopyPartResult `type:"structure"`

	// The version of the source object that was copied, if you have enabled versioning
	// on the source bucket.
	CopySourceVersionID *string `location:"header" locationName:"x-amz-copy-source-version-id" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	metadataUploadPartCopyOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataUploadPartCopyOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"CopyPartResult"`
}

type UploadPartInput struct {
	Body io.ReadSeeker `type:"blob"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Size of the body in bytes. This parameter is useful when the size of the
	// body cannot be determined automatically.
	ContentLength *int64 `location:"header" locationName:"Content-Length" type:"integer"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// Part number of part being uploaded.
	PartNumber *int64 `location:"querystring" locationName:"partNumber" type:"integer" required:"true"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header. This must be the same encryption key specified in the initiate multipart
	// upload request.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Upload ID identifying the multipart upload whose part is being uploaded.
	UploadID *string `location:"querystring" locationName:"uploadId" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	TrafficLimit *int64 `location:"header" locationName:"x-kss-traffic-limit" type:"string"`

	ContentMD5 *string `location:"header" locationName:"Content-MD5" type:"string"`

	// Progress callback function
	ProgressFn aws.ProgressFunc `location:"function"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataUploadPartInput `json:"-" xml:"-"`
}

type metadataUploadPartInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Body"`
}

type UploadPartOutput struct {
	// Entity tag for the uploaded object.
	ETag *string `location:"header" locationName:"ETag" type:"string"`

	// CRC64 value of a single part.
	ChecksumCRC64ECMA *string `location:"header" locationName:"x-amz-checksum-crc64ecma" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	metadataUploadPartOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataUploadPartOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type VersioningConfiguration struct {
	// Specifies whether MFA delete is enabled in the bucket versioning configuration.
	// This element is only returned if the bucket has been configured with MFA
	// delete. If the bucket has never been so configured, this element is not returned.
	MFADelete *string `locationName:"MfaDelete" type:"string"`

	// The versioning state of the bucket.
	Status *string `type:"string"`

	metadataVersioningConfiguration `json:"-" xml:"-"`
}

type metadataVersioningConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

type WebsiteConfiguration struct {
	ErrorDocument *ErrorDocument `type:"structure"`

	IndexDocument *IndexDocument `type:"structure"`

	RedirectAllRequestsTo *RedirectAllRequestsTo `type:"structure"`

	RoutingRules []*RoutingRule `locationNameList:"RoutingRule" type:"list"`

	metadataWebsiteConfiguration `json:"-" xml:"-"`
}

type metadataWebsiteConfiguration struct {
	SDKShapeTraits bool `type:"structure"`
}

func (c *S3) DeleteObjectTaggingRequest(input *DeleteObjectTaggingInput) (req *aws.Request, output *DeleteObjectTaggingOutput) {
	op := &aws.Operation{
		Name:       "DeleteObjectTagging",
		HTTPMethod: "DELETE",
		HTTPPath:   "/{Bucket}/{Key+}?tagging",
	}

	if input == nil {
		input = &DeleteObjectTaggingInput{}
	}

	req = c.newRequest(op, input, output)
	output = &DeleteObjectTaggingOutput{}
	req.Data = output
	return
}

func (c *S3) DeleteObjectTagging(input *DeleteObjectTaggingInput) (*DeleteObjectTaggingOutput, error) {
	req, out := c.DeleteObjectTaggingRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) DeleteObjectTaggingWithContext(ctx aws.Context, input *DeleteObjectTaggingInput) (*DeleteObjectTaggingOutput, error) {
	req, out := c.DeleteObjectTaggingRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

type DeleteObjectTaggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataDeleteObjectTaggingInput `json:"-" xml:"-"`
}

type metadataDeleteObjectTaggingInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteObjectTaggingOutput struct {
	metadataDeleteObjectTaggingOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataDeleteObjectTaggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// GetObjectTaggingRequest generates a request for the GetObjectTagging operation.
func (c *S3) GetObjectTaggingRequest(input *GetObjectTaggingInput) (req *aws.Request, output *GetObjectTaggingOutput) {
	op := &aws.Operation{
		Name:       "GetObjectTagging",
		HTTPMethod: "GET",
		HTTPPath:   "/{Bucket}/{Key+}?tagging",
	}

	if input == nil {
		input = &GetObjectTaggingInput{}
	}

	req = c.newRequest(op, input, output)
	output = &GetObjectTaggingOutput{}
	req.Data = output
	return
}

// GetObjectTagging gets the tagging configuration for an object.
func (c *S3) GetObjectTagging(input *GetObjectTaggingInput) (*GetObjectTaggingOutput, error) {
	req, out := c.GetObjectTaggingRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) GetObjectTaggingWithContext(ctx aws.Context, input *GetObjectTaggingInput) (*GetObjectTaggingOutput, error) {
	req, out := c.GetObjectTaggingRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

type GetObjectTaggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataGetObjectTaggingInput `json:"-" xml:"-"`
}

type metadataGetObjectTaggingInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetObjectTaggingOutput struct {
	Tagging *Tagging `locationName:"Tagging" type:"structure"`

	metadataGetObjectTaggingOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataGetObjectTaggingOutput struct {
	SDKShapeTraits bool `type:"structure" payload:"Tagging"`
}

// PutObjectTaggingRequest generates a request for the PutObjectTagging operation.
func (c *S3) PutObjectTaggingRequest(input *PutObjectTaggingInput) (req *aws.Request, output *PutObjectTaggingOutput) {
	op := &aws.Operation{
		Name:       "PutObjectTagging",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}?tagging",
	}

	if input == nil {
		input = &PutObjectTaggingInput{}
	}
	input.ContentType = aws.String("application/xml")
	req = c.newRequest(op, input, output)
	output = &PutObjectTaggingOutput{}
	req.Data = output
	return
}

// PutObjectTagging sets the tagging configuration for an object.
func (c *S3) PutObjectTagging(input *PutObjectTaggingInput) (*PutObjectTaggingOutput, error) {
	req, out := c.PutObjectTaggingRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) PutObjectTaggingWithContext(ctx aws.Context, input *PutObjectTaggingInput) (*PutObjectTaggingOutput, error) {
	req, out := c.PutObjectTaggingRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

type PutObjectTaggingInput struct {
	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	Tagging *Tagging `locationName:"Tagging" type:"structure"`

	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataPutObjectTaggingInput `json:"-" xml:"-"`
}

type metadataPutObjectTaggingInput struct {
	SDKShapeTraits bool `type:"structure" payload:"Tagging"`
}

type PutObjectTaggingOutput struct {
	metadataPutObjectTaggingOutput `json:"-" xml:"-"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`
}

type metadataPutObjectTaggingOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// FetchObjectRequest generates a request for the FetchObject operation.
func (c *S3) FetchObjectRequest(input *FetchObjectInput) (req *aws.Request, output *FetchObjectOutput) {
	op := &aws.Operation{
		Name:       "FetchObject",
		HTTPMethod: "PUT",
		HTTPPath:   "/{Bucket}/{Key+}?fetch",
	}

	if input == nil {
		input = &FetchObjectInput{}
	}

	if input.SourceUrl != nil {
		input.SourceUrl = aws.String(url.QueryEscape(*input.SourceUrl))
	}
	req = c.newRequest(op, input, output)
	output = &FetchObjectOutput{}
	req.Data = output
	return
}

func (c *S3) FetchObject(input *FetchObjectInput) (*FetchObjectOutput, error) {
	req, out := c.FetchObjectRequest(input)
	err := req.Send()
	return out, err
}

func (c *S3) FetchObjectWithContext(ctx aws.Context, input *FetchObjectInput) (*FetchObjectOutput, error) {
	req, out := c.FetchObjectRequest(input)
	req.SetContext(ctx)
	err := req.Send()
	return out, err
}

type FetchObjectInput struct {
	// The canned ACL to apply to the object.
	ACL *string `location:"header" locationName:"x-kss-acl" type:"string"`

	Bucket *string `location:"uri" locationName:"Bucket" type:"string" required:"true"`

	// Specifies caching behavior along the request/reply chain.
	CacheControl *string `location:"header" locationName:"Cache-Control" type:"string"`

	// Specifies presentational information for the object.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// Specifies what content encodings have been applied to the object and thus
	// what decoding mechanisms must be applied to obtain the media-type referenced
	// by the Content-Type header field.
	ContentEncoding *string `location:"header" locationName:"Content-Encoding" type:"string"`

	// The language the content is in.
	ContentLanguage *string `location:"header" locationName:"Content-Language" type:"string"`

	// A standard MIME type describing the format of the object data.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`

	// The name of the source bucket and key name of the source object, separated
	// by a slash (/). Must be URL-encoded.
	SourceUrl *string `location:"header" locationName:"x-kss-sourceurl" type:"string" required:"true"`

	CallbackUrl *string `location:"header" locationName:"x-kss-callbackurl" type:"string"`

	// The date and time at which the object is no longer cacheable.
	Expires *time.Time `location:"header" locationName:"Expires" type:"timestamp" timestampFormat:"rfc822"`

	// Gives the grantee READ, READ_ACP, and WRITE_ACP permissions on the object.
	GrantFullControl *string `location:"header" locationName:"x-amz-grant-full-control" type:"string"`

	// Allows grantee to read the object data and its metadata.
	GrantRead *string `location:"header" locationName:"x-amz-grant-read" type:"string"`

	// Allows grantee to read the object ACL.
	GrantReadACP *string `location:"header" locationName:"x-amz-grant-read-acp" type:"string"`

	// Allows grantee to write the ACL for the applicable object.
	GrantWriteACP *string `location:"header" locationName:"x-amz-grant-write-acp" type:"string"`

	Key *string `location:"uri" locationName:"Key" type:"string" required:"true"`

	// A map of metadata to store with the object in S3.
	Metadata map[string]*string `location:"headers" locationName:"x-amz-meta-" type:"map"`

	// Specifies whether the metadata is copied from the source object or replaced
	// with metadata provided in the request.
	MetadataDirective *string `location:"header" locationName:"x-amz-metadata-directive" type:"string"`

	// Confirms that the requester knows that she or he will be charged for the
	// request. Bucket owners need not specify this parameter in their requests.
	// Documentation on downloading objects from requester pays buckets can be found
	// at http://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html
	RequestPayer *string `location:"header" locationName:"x-amz-request-payer" type:"string"`

	// Specifies the algorithm to use to when encrypting the object (e.g., AES256,
	// aws:kms).
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// Specifies the customer-provided encryption key for Amazon S3 to use in encrypting
	// data. This value is used to store the object and then it is discarded; Amazon
	// does not store the encryption key. The key must be appropriate for use with
	// the algorithm specified in the x-amz-server-side​-encryption​-customer-algorithm
	// header.
	SSECustomerKey *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key" type:"string"`

	// Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321.
	// Amazon S3 uses this header for a message integrity check to ensure the encryption
	// key was transmitted without error.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// Specifies the AWS KMS key ID to use for object encryption. All GET and PUT
	// requests for an object protected by AWS KMS will fail if not made via SSL
	// or using SigV4. Documentation on configuring any of the officially supported
	// AWS SDKs and CLI can be found at http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	// The type of storage to use for the object. Defaults to 'STANDARD'.
	StorageClass *string `location:"header" locationName:"x-amz-storage-class" type:"string"`

	// If the bucket is configured as a website, redirects requests for this object
	// to another object in the same bucket or to an external URL. Amazon S3 stores
	// the value of this header in the object metadata.
	WebsiteRedirectLocation *string `location:"header" locationName:"x-amz-website-redirect-location" type:"string"`

	// Specifies the object tag of the object. Multiple tags can be set at the same time, such as: TagA=A&TagB=B.
	// Note: Key and Value need to be URL-encoded first. If an item does not have "=", the Value is considered to be an empty string.
	Tagging *string `location:"header" locationName:"x-amz-tagging" type:"string"`

	// Set extend request headers. If the existing fields do not support setting the request header you need, you can set it through this field.
	ExtendHeaders map[string]*string `location:"extendHeaders" type:"map"`

	// Set extend query params. If the existing fields do not support setting the query param you need, you can set it through this field.
	ExtendQueryParams map[string]*string `location:"extendQueryParams" type:"map"`

	metadataFetchObjectInput `json:"-" xml:"-"`
}

type metadataFetchObjectInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type FetchObjectOutput struct {

	// If the object expiration is configured, the response includes this header.
	Expiration *string `location:"header" locationName:"x-amz-expiration" type:"string"`

	// If present, indicates that the requester was successfully charged for the
	// request.
	RequestCharged *string `location:"header" locationName:"x-amz-request-charged" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header confirming the encryption algorithm
	// used.
	SSECustomerAlgorithm *string `location:"header" locationName:"x-amz-server-side-encryption-customer-algorithm" type:"string"`

	// If server-side encryption with a customer-provided encryption key was requested,
	// the response will include this header to provide round trip message integrity
	// verification of the customer-provided encryption key.
	SSECustomerKeyMD5 *string `location:"header" locationName:"x-amz-server-side-encryption-customer-key-MD5" type:"string"`

	// If present, specifies the ID of the AWS Key Management Service (KMS) master
	// encryption key that was used for the object.
	SSEKMSKeyID *string `location:"header" locationName:"x-amz-server-side-encryption-aws-kms-key-id" type:"string"`

	// The Server-side encryption algorithm used when storing this object in S3
	// (e.g., AES256, aws:kms).
	ServerSideEncryption *string `location:"header" locationName:"x-amz-server-side-encryption" type:"string"`

	Metadata map[string]*string `location:"headers"  type:"map"`

	StatusCode *int64 `location:"statusCode" type:"integer"`

	metadataFetchObjectOutput `json:"-" xml:"-"`
}

type metadataFetchObjectOutput struct {
	SDKShapeTraits bool `type:"structure"`
}
